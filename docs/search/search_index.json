{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is mbake? mbake is a modern CLI static app generation tool. Apps and sites you generate with mbake are extreme serverless, allow user authentication and work with JSON and database APIs for dynamic databinding. You can use mbake for simple blogs or sites to the most complex web and mobile app projects. If you don't have time, see tl;dr at the bottom of this page. mbake compares to other static generators and grunt/gulp; but it does a lot more with a lot less coding. mbake is part of the MetaBake\u2122 approach but can be used by itself. What is MetaBake? MetaBake\u2122 is a modern development approach that helps you deliver web apps 10X faster with less coding. MetaBake\u2122 has 10 pillars. Find out more about MetaBake: Quick Demo Meetup Video Slide Deck Summary for Managers MetaBake allows for gradual adoption. You can start by adopting just one or a few of its pillars. mbake is a good start. MetaBake and mbake are open source. The source code is available at github.com/MetaBake See Resources for related projects. How to install mbake From a command line such as PowerShell, type: $ yarn global add mbake That's it! If you don't have Yarn installed, first go here . How to create a Hello World app with mbake ## Create index.pug header body p Hello #{key1} ## Create dat.yaml key1: World ## Generate index.html from Pug and Yaml: mbake . or: mbake subfoldername Auto-build/generate: if you are using a MetaBake META build server (see META doc), you don't even have to do the 'mbake .'. META has a watcher that triggers 'mbake' when you save a file. How to run an mbake app (such as Hello World) mbake apps run on any static web server. This includes low-cost cloud hosting such as Amazon S3. We show how to work with S3 later in this doc. When you develop locally, you could use 'Web Server for Chrome' to run mbake apps. To install it, open your Google Chrome web browser and install the 'Web Server for Chrome' app from here . Launch the app, click the 'Choose Folder' button and select the root folder of your app (e.g. where index.html of your Hello World app is). Also ensure 'Options' has 'Automatically show index.html' checked. Ensure the Web Server is STARTED, then navigate to the proposed URL (e.g. http://127.0.0.1:8887). Even though mbake apps are installed on a static server, they are dynamic because they allow user authentication and work with JSON for dynamic rendering and database APIs for dynamic databinding. How to generate a sample app with mbake ## Run mbake help to see the list of current sample apps mbake ## Generate sample app, e.g. mbake -v ## Navigate to it, e.g. cd crud Other popular mbake commands mbake -t . - Convert Pug/Riot files to useable tag/js, e.g.: data binding. mbake -i . - Convert dat.yaml static files to JSON, for dynamic binding. More about this in B-M-SPA docs. How to see all mbake options $ mbake How to make mbake apps serverless To go extreme serverless, we show how to use mbake with Amazon Web Services (AWS) S3 HTTP hosting Mounting software so you can mount AWS S3 as a drive Google Firebase/Firestore Go extreme serverless following the steps (Tutorials): Setup S3 as your HTTP server and mount it Mount S3 to linux box via goofys using CodeAnywhere editor Learn Pug and static binding; view via S3 HTTP server Spectre SCSS Theme Framework and SCSS dynamic databinding Generate a serverless CRUD webapp Simple CRUD example app and ViewModel+Bind Design Blog When done, you should see this . Serverless/Cloud V2, Mount and Pug are some of the pillars of MetaBake. tl;dr $ yarn global add mbake $ mbake $ mbake -v $ cd ModelView $ mbake . NEXT: Go to Setup S3 as your HTTP server and mount it .","title":"Home"},{"location":"#what-is-mbake","text":"mbake is a modern CLI static app generation tool. Apps and sites you generate with mbake are extreme serverless, allow user authentication and work with JSON and database APIs for dynamic databinding. You can use mbake for simple blogs or sites to the most complex web and mobile app projects. If you don't have time, see tl;dr at the bottom of this page. mbake compares to other static generators and grunt/gulp; but it does a lot more with a lot less coding. mbake is part of the MetaBake\u2122 approach but can be used by itself.","title":"What is mbake?"},{"location":"#what-is-metabake","text":"MetaBake\u2122 is a modern development approach that helps you deliver web apps 10X faster with less coding. MetaBake\u2122 has 10 pillars. Find out more about MetaBake: Quick Demo Meetup Video Slide Deck Summary for Managers MetaBake allows for gradual adoption. You can start by adopting just one or a few of its pillars. mbake is a good start. MetaBake and mbake are open source. The source code is available at github.com/MetaBake See Resources for related projects.","title":"What is MetaBake?"},{"location":"#how-to-install-mbake","text":"From a command line such as PowerShell, type: $ yarn global add mbake That's it! If you don't have Yarn installed, first go here .","title":"How to install mbake"},{"location":"#how-to-create-a-hello-world-app-with-mbake","text":"## Create index.pug header body p Hello #{key1} ## Create dat.yaml key1: World ## Generate index.html from Pug and Yaml: mbake . or: mbake subfoldername Auto-build/generate: if you are using a MetaBake META build server (see META doc), you don't even have to do the 'mbake .'. META has a watcher that triggers 'mbake' when you save a file.","title":"How to create a Hello World app with mbake"},{"location":"#how-to-run-an-mbake-app-such-as-hello-world","text":"mbake apps run on any static web server. This includes low-cost cloud hosting such as Amazon S3. We show how to work with S3 later in this doc. When you develop locally, you could use 'Web Server for Chrome' to run mbake apps. To install it, open your Google Chrome web browser and install the 'Web Server for Chrome' app from here . Launch the app, click the 'Choose Folder' button and select the root folder of your app (e.g. where index.html of your Hello World app is). Also ensure 'Options' has 'Automatically show index.html' checked. Ensure the Web Server is STARTED, then navigate to the proposed URL (e.g. http://127.0.0.1:8887). Even though mbake apps are installed on a static server, they are dynamic because they allow user authentication and work with JSON for dynamic rendering and database APIs for dynamic databinding.","title":"How to run an mbake app (such as Hello World)"},{"location":"#how-to-generate-a-sample-app-with-mbake","text":"## Run mbake help to see the list of current sample apps mbake ## Generate sample app, e.g. mbake -v ## Navigate to it, e.g. cd crud","title":"How to generate a sample app with mbake"},{"location":"#other-popular-mbake-commands","text":"mbake -t . - Convert Pug/Riot files to useable tag/js, e.g.: data binding. mbake -i . - Convert dat.yaml static files to JSON, for dynamic binding. More about this in B-M-SPA docs.","title":"Other popular mbake commands"},{"location":"#how-to-see-all-mbake-options","text":"$ mbake","title":"How to see all mbake options"},{"location":"#how-to-make-mbake-apps-serverless","text":"To go extreme serverless, we show how to use mbake with Amazon Web Services (AWS) S3 HTTP hosting Mounting software so you can mount AWS S3 as a drive Google Firebase/Firestore","title":"How to make mbake apps serverless"},{"location":"#go-extreme-serverless-following-the-steps-tutorials","text":"Setup S3 as your HTTP server and mount it Mount S3 to linux box via goofys using CodeAnywhere editor Learn Pug and static binding; view via S3 HTTP server Spectre SCSS Theme Framework and SCSS dynamic databinding Generate a serverless CRUD webapp Simple CRUD example app and ViewModel+Bind Design Blog When done, you should see this . Serverless/Cloud V2, Mount and Pug are some of the pillars of MetaBake.","title":"Go extreme serverless following the steps (Tutorials):"},{"location":"#tldr","text":"$ yarn global add mbake $ mbake $ mbake -v $ cd ModelView $ mbake . NEXT: Go to Setup S3 as your HTTP server and mount it .","title":"tl;dr"},{"location":"about/","text":"Click for 'THE' mbake Docs low-code = 10X faster web app development. With MetaBake's modern development approach, it is not about replacing your tech stack with another tech stack -- it is about eliminating it! About MetaBake mBake.org is a development productivity suite. It should allow you to deliver 10 times faster then legacy development stacks/methodologies. We have found that - with mBake.org; - the work of 6 developers over 6 months can be done by 3 developers in 3 weeks. We expect you to achieve the same productivity gains. How does open source MetaBake deliver 10X faster and cheaper web app development? Not enough organizations are fully leveraging the new Serverless. With Serverless services like Firestore and S3 you get rid of ALL server-side and middleware development and operations. This is where up to 2/3 of your time and cost used to go. Gone! On the client side (browser apps and mobile apps) MetaBake does something similar: it eliminates much of the tech stack and reduces the amount of coding and complexity. How? In school textbooks you learned about 1st generation languages, 2nd generation languages and our current 3rd generation languages, such as JavaScript, PHP and Ruby. With each new generation we achieved huge productivity improvements. We consider 'Pug'--also used by Node/Express--a 4th generation language that helps gain an equally big jump in productivity. With MetaBake we show you how to build complete applications in Pug. With this low-code approach we demonstrate much faster and cheaper web app and mobile app development. The MetaBake approach has 10 pillars that are the foundation for achieving mind-blowing development productivity gains. I'll just mention one more pillar here: automatic programming. You've probably heard of 'static site generators' like Hugo or Jekyll that people use to generate their web site or a blog. Automatic programming means using a similar generator to write your web app! This can get you to yet another level of productivity. To learn more about the MetaBake approach, including all 10 pillars and full examples, go to mBake.org. Or, to dive in right away, use the 'mbake CLI' from github.com/MetaBake as the first step into 10X faster web app development. mBake.org productivity is based on three modules: mbake, a static site generation tool that runs locally B-M-SPA, curated technologies and techniques that help you build dynamic apps and mobile apps faster Meta, a bespoke cloud-based build and admin app infrastructure that helps deliver functionality to your clients more quickly We benchmark against LAMP , RAILS , MEAN and such For example, LAMP is the technology WordPress was built on. Every 10 years or so technology gets 10 times better, which forces everyone to upgrade. Assembly was 10 times better than machine language. C/.js is 10 times better than Assembly. We believe that we found the answer on how to have a more productive team. So far, somehow, server-side rendered LAMP has dominated web deployments, with WordPress having some 30% of the World Wide Web. It is time to start displacing that. You can reinvest the time saved by using MetaBake into a more interactive user experience (UX). Better UX is proven to lead into higher user engagement and better user retention. About mbake mbake leverages the clarity, simplicity and productivity gained by using the declarative markup language Pug . We think of Pug as 4GL. mbake currently compiles Pug, Markdown and Yaml to generate HTML and JSON. Using the power of JavaScript, more transformers can be added. mbake runs as a small node process, either on your machine or in the cloud. mbake generates static sites, but it also supports making those sites dynamic with API calls and data feeds such as from JSON. mbake helps is another example of a http://staticgen.com webapp. mbake includes sample starters apps for CRUD. After you are comfortable with mbake, check out B-M-SPA and Meta. Prerequisites: you should know HTML and CSS. If you need to catch up, we recommend 'Design and Build Websites' by Jon Duckett. You will also learn Pug, to get started on Pug, watch Pug on Youtube Best way to get started with mbake is to read the Docs, linked at he top of the page.","title":"About"},{"location":"about/#low-code-10x-faster-web-app-development","text":"","title":"low-code = 10X faster web app development."},{"location":"about/#with-metabakes-modern-development-approach-it-is-not-about-replacing-your-tech-stack-with-another-tech-stack-it-is-about-eliminating-it","text":"","title":"With MetaBake's modern development approach, it is not about replacing your tech stack with another tech stack -- it is about eliminating it!"},{"location":"about/#about-metabake","text":"mBake.org is a development productivity suite. It should allow you to deliver 10 times faster then legacy development stacks/methodologies. We have found that - with mBake.org; - the work of 6 developers over 6 months can be done by 3 developers in 3 weeks. We expect you to achieve the same productivity gains. How does open source MetaBake deliver 10X faster and cheaper web app development? Not enough organizations are fully leveraging the new Serverless. With Serverless services like Firestore and S3 you get rid of ALL server-side and middleware development and operations. This is where up to 2/3 of your time and cost used to go. Gone! On the client side (browser apps and mobile apps) MetaBake does something similar: it eliminates much of the tech stack and reduces the amount of coding and complexity. How? In school textbooks you learned about 1st generation languages, 2nd generation languages and our current 3rd generation languages, such as JavaScript, PHP and Ruby. With each new generation we achieved huge productivity improvements. We consider 'Pug'--also used by Node/Express--a 4th generation language that helps gain an equally big jump in productivity. With MetaBake we show you how to build complete applications in Pug. With this low-code approach we demonstrate much faster and cheaper web app and mobile app development. The MetaBake approach has 10 pillars that are the foundation for achieving mind-blowing development productivity gains. I'll just mention one more pillar here: automatic programming. You've probably heard of 'static site generators' like Hugo or Jekyll that people use to generate their web site or a blog. Automatic programming means using a similar generator to write your web app! This can get you to yet another level of productivity. To learn more about the MetaBake approach, including all 10 pillars and full examples, go to mBake.org. Or, to dive in right away, use the 'mbake CLI' from github.com/MetaBake as the first step into 10X faster web app development.","title":"About MetaBake"},{"location":"about/#mbakeorg-productivity-is-based-on-three-modules","text":"mbake, a static site generation tool that runs locally B-M-SPA, curated technologies and techniques that help you build dynamic apps and mobile apps faster Meta, a bespoke cloud-based build and admin app infrastructure that helps deliver functionality to your clients more quickly We benchmark against LAMP , RAILS , MEAN and such For example, LAMP is the technology WordPress was built on. Every 10 years or so technology gets 10 times better, which forces everyone to upgrade. Assembly was 10 times better than machine language. C/.js is 10 times better than Assembly. We believe that we found the answer on how to have a more productive team. So far, somehow, server-side rendered LAMP has dominated web deployments, with WordPress having some 30% of the World Wide Web. It is time to start displacing that. You can reinvest the time saved by using MetaBake into a more interactive user experience (UX). Better UX is proven to lead into higher user engagement and better user retention.","title":"mBake.org productivity is based on three modules:"},{"location":"about/#about-mbake","text":"mbake leverages the clarity, simplicity and productivity gained by using the declarative markup language Pug . We think of Pug as 4GL. mbake currently compiles Pug, Markdown and Yaml to generate HTML and JSON. Using the power of JavaScript, more transformers can be added. mbake runs as a small node process, either on your machine or in the cloud. mbake generates static sites, but it also supports making those sites dynamic with API calls and data feeds such as from JSON. mbake helps is another example of a http://staticgen.com webapp. mbake includes sample starters apps for CRUD. After you are comfortable with mbake, check out B-M-SPA and Meta. Prerequisites: you should know HTML and CSS. If you need to catch up, we recommend 'Design and Build Websites' by Jon Duckett. You will also learn Pug, to get started on Pug, watch Pug on Youtube Best way to get started with mbake is to read the Docs, linked at he top of the page.","title":"About mbake"},{"location":"blog/","text":"Blog website With the command you can download a blog website example: $ mbake -b -b is blog. It also works for any items, not just articles. In blog, copy folder /blog/post-1 to /blog/blog, rename it to post-1n . Edit some of the content, like the .md file so it's different. Then in /blog run $ mbake -i . That creates a new items.json file. Now view the home page in browser: the new item shows up! The home page does a ajax fetch of the json and shows it. Via a pagination library. Check out the component in /blog/blog/components that is the items loop. You should know now how to add any items and show the list of items. When someone adds a new item (via a new folder) it shows up after $ mbake -i . Notice how everything in /blog/blog/post-*/dat.yaml ends up in /blog items.json . That is used in the list. So dat.yaml can show on page, as you learnt from previous tutorials. And can show in list - as above described how to make items.json. That list can then be used by a component 'iterator'.","title":"Blog"},{"location":"blog/#blog-website","text":"With the command you can download a blog website example: $ mbake -b -b is blog. It also works for any items, not just articles. In blog, copy folder /blog/post-1 to /blog/blog, rename it to post-1n . Edit some of the content, like the .md file so it's different. Then in /blog run $ mbake -i . That creates a new items.json file. Now view the home page in browser: the new item shows up! The home page does a ajax fetch of the json and shows it. Via a pagination library. Check out the component in /blog/blog/components that is the items loop. You should know now how to add any items and show the list of items. When someone adds a new item (via a new folder) it shows up after $ mbake -i . Notice how everything in /blog/blog/post-*/dat.yaml ends up in /blog items.json . That is used in the list. So dat.yaml can show on page, as you learnt from previous tutorials. And can show in list - as above described how to make items.json. That list can then be used by a component 'iterator'.","title":"Blog website"},{"location":"ca/","text":"Mount linux box folder to another linux box using CodeAnywhere editor Setup cloud dev. Setup up a Linux box in the cloud, e.g. Digital Ocean . Change the root password for DO linux box. Connect by ssh in terminal. It will ask to enter existing password and then new password: $ ssh root@[IP-Address] In CA (assuming that you have an account in CA, done in previous tutorial), connect to the Linux box. In CA, open SSH to the Linux box. Mount folder from Linux machine on another Linux machine <!--- 2. Login to CA and create a new connection to connect to your recently created Linux box in Digital Ocean. 3. Open terminal in CA in this linux box and install sshfs for mount: $ apt install aptitude $ apt-add-repository universe $ sudo apt-get install sshfs $ mkdir mount // change [mount] with any name you like $ sshfs user_kpq3rmpl@push-33.cdn77.com:/ mount // ($ sshfs [user]@[host]:/ [name-of-folder-to-mount-in]) now you will have a mount directory in your linux box that has mounted CDN Storage inside. For more information on installing sshfs on linux check [Using SSHFS To Mount Remote Directories](https://www.linode.com/docs/networking/ssh/using-sshfs-on-linux/) Then on linux box install node, yarn and mbake. Via git, pull the latest version of some project from the git repository in your mount/www folder. Change some file, .pug or .js or readme - $ mbake . it and push to the git repository. Now you've learned how to develop and operate in the cloud and you can edit your mounted CDN storage files from CodeAnywhere ssh. In the next tutorial you will learn about Pug and static data binding. NEXT: Go to Templating/Pug and static binding . -->","title":"Mount linux box folder to another linux box using CodeAnywhere editor"},{"location":"ca/#mount-linux-box-folder-to-another-linux-box-using-codeanywhere-editor","text":"","title":"Mount linux box folder to another linux box using CodeAnywhere editor"},{"location":"ca/#setup-cloud-dev","text":"Setup up a Linux box in the cloud, e.g. Digital Ocean . Change the root password for DO linux box. Connect by ssh in terminal. It will ask to enter existing password and then new password: $ ssh root@[IP-Address] In CA (assuming that you have an account in CA, done in previous tutorial), connect to the Linux box. In CA, open SSH to the Linux box.","title":"Setup cloud dev."},{"location":"ca/#mount-folder-from-linux-machine-on-another-linux-machine","text":"<!--- 2. Login to CA and create a new connection to connect to your recently created Linux box in Digital Ocean. 3. Open terminal in CA in this linux box and install sshfs for mount: $ apt install aptitude $ apt-add-repository universe $ sudo apt-get install sshfs $ mkdir mount // change [mount] with any name you like $ sshfs user_kpq3rmpl@push-33.cdn77.com:/ mount // ($ sshfs [user]@[host]:/ [name-of-folder-to-mount-in]) now you will have a mount directory in your linux box that has mounted CDN Storage inside. For more information on installing sshfs on linux check [Using SSHFS To Mount Remote Directories](https://www.linode.com/docs/networking/ssh/using-sshfs-on-linux/) Then on linux box install node, yarn and mbake. Via git, pull the latest version of some project from the git repository in your mount/www folder. Change some file, .pug or .js or readme - $ mbake . it and push to the git repository. Now you've learned how to develop and operate in the cloud and you can edit your mounted CDN storage files from CodeAnywhere ssh. In the next tutorial you will learn about Pug and static data binding. NEXT: Go to Templating/Pug and static binding . -->","title":"Mount folder from Linux machine on another Linux machine"},{"location":"crud/","text":"Generate a serverless CRUD webapp. CRUD stands for create-read-update-delete. In this tutorial, you will learn how to create your own Firestore database. Firestore database is part of the Google Firestore offering. Similar to AWS Cognito, Firestore includes pure client-side user authentication. Firestore can be used from the browser via JavaScript; no custom serverside code is needed. This is key to be able to develop faster. Firestore is free for up to 50,000 reads and 20,000 writes per day. See more details here . At the time of writing, Firestore is a beta version, but Gmail also was beta for a very long time, without major issues. Firestore has a clean and mature API that is much improved from a previous version of Firebase. Steps Using the AWS S3 browser, create a bucket in the same region as you used in Setup S3 as your HTTP server and mount it . Name the bucket 'wgehner-crud' (replace 'wgehner' with your name or something else unique). Configure the bucket for static website hosting and apply the access policy analog to the 'website' project ( Step 4 ). Copy the Endpoint URL. The new bucket should appear as a new project root folder in your mapped drive (e.g. as W:\\wgehner-crud ). Extract the CRUD sample project to your computer with '$ mbake -v' and copy the project files (inside of /crud ) into the project root. In a browser, open the Endpoint URL. You should see the CRUD App served by S3. Navigate to the 'ViewModel CRUD' menu item. Inspect the fragment /screen/example1/index.pug . Note the table#table1 and table#table2 tags, an empty tables with ID #table1 and #table2 which fills with data using tabulator.js library. Next is how table is getting filled with data. getViewList('table1', 'table2') function is called from the bind file Example1Bind.js : getViewList(tableID, tableID2){ let _this = this let columns1 = [ //Define Table Columns {title:\"Col1\", field:\"col1\", align:\"left\", width:150}, {title:\"Col2\", field:\"col2\", align:\"left\", width:'70%'}, ]; let columns2 = [ //Define Table Columns {title:\"Col45\", field:\"col45\", align:\"left\", width:'70%'}, {title:\"Col55\", field:\"col55\", align:\"left\", width:'70%'}, ]; Promise.all([this.viewModel.read()]) .then(function(){ let data1 = _this.viewModel.getViewList(tableID) let data2 = _this.viewModel.getViewList(tableID2) _this.setTable(tableID, columns1, data1) _this.setTable(tableID2, columns2, data2) }) } then function this.viewModel.read() is called from the 'view-model' file assets/models/Example1ViewModel.js : read(){ let _this = this return Promise.all([this.exampleModel.read()]) .then(function(data){ _this._data = [].concat(data[0]) }) //maybe other read methods from a diffrent entity } and then this.exampleModel.read() function is called from assets/models/service/Example1Service.js : read(id?:string){ let _this = this console.info('--reading...', Date.now() - _start) let ref = db1.collection(this.entityName) if(id){ return db1.collection(this.entityName).doc(id) .get() .then(function(docSnap) { let temp = docSnap.data() temp['id'] = docSnap.id // Object.assign(_this._dataObj, temp) return temp }) .catch(function(error) { console.info(\"Error getting documents: \", error) }) } return ref .get() .then(function(querySnapshot) { let rows = [] querySnapshot.forEach(function(doc) { let row = doc.data() row['id'] = doc.id rows.push(row) }) return rows }) .catch(function(error) { console.info(\"Error getting documents: \", error) }) }//() it reads the data from the Firestore database and fills the table with the content. This is an example of a 'View-model' pattern. In View-model pattern each page should have a bind file and a ViewModel file. In bind file, eg Example1Bind.js , there is all that \u0441oncerns UI functionallity. In ViewModel file, eg: assets/models/Example1ViewModel.js there are the data samples 'real' or 'fake' which are then mapped with the data from the database in file assets/models/service/Example1Service.js in which create/read/update/delete functionallity directly occurs. Inspect /screen/auth/modA.pug the form that used here is styled with gridforms . If you will open screen/auth/modA.pug you can see this form. Here is the example of Firebase authentication. You can try to create user, reset password, sign-in and log out in browser on screen/auth page. The Firestore function to login with email and password: auth.signInWithEmailAndPassword(email,pswd) .then(function(user) { console.info(user) alert('Signed in successfully') //replace with pretty popup }) .catch(function(error){ console.info(error) alert(error) // replace with pretty popup }) the function to sign up a new user with email and password: auth.createUserWithEmailAndPassword(email,pswd) .then(function(user) { bAuth.sendEmailVerification() }) .catch(function(error){ console.info(error) //show error in .message alert(error) // replace with pretty popup }) the function that will sent reset password link to the user email: auth.sendPasswordResetEmail(email) and the function to log out: auth.signOut() all of them triggers on appropriate buttons click. To learn Firebase, you will now remap the Firestore connection to your own Firestore. Create a Google account if you don't already have one. Log into https://console.firebase.google.com . Create a project named test-crud . Under the left menu 'Develop - Database', create a Firestore app in test mode. On the Project Overview, click the </> button near 'Add an app to get started' to open a popup. In your mapped project /assets/comps/preRW-comp.pug , overwrite the values for apiKey, authDomain and projectId with the values shown in the Firestore popup and save. Run '$ mbake -t .' from the tags folder. ( /layout/layout.pug will use the updated script(src='/assets/comps/preRW-comp.min.js') .) We will now secure the database. In the Firestore Console, on the Rules tab in 'Develop - Database', replace: allow: read, write; with allow read, write: if request.auth.token.email_verified == true; Only logged in users who have been verified by email can now read from or write to the database. Since you are currently not logged in, 'Add data' on the 'CRUD' screen should now fail. We will now configure and test a sign-in method. In the Firestore Console, in 'Develop - Authentication', click on 'Set up sign-in method'. Enable Email/Password sign-up and save. In the CRUD App, navigate to the multi-purpose 'Auth' screen (/screen/auth/). Enter your email and a password and click the 'Sign Up' button. The new user should appear in the Firestore Authentication list of Users. Check your email and click on the link you received (The email can be customized on the Firestore Authentication Templates tab). Return to the Auth screen (/screen/auth/) and click the 'Sign In' button. If the login succeeded, 'Add row' on the 'View-Model CRUD' screen should now succeed, and you should see the added data in the Firestore database console. Summary: You learnt how to create your own Firestore database, insert data and add authentication to the app. Firestore replaces MongoDB, but also ORM, REST, DevOps, Security, Failover, etc. Instead of learning all of these, now you only need to learn how to use Firestore. That should create a huge savings in your development and operations budget. NEXT STEPS: You can try out more Template projects (type $ mbake ). You can also setup a META build server. META has a watcher that triggers 'mbake' when you save a file to a mapped drive. You can become 10X more productive by adopting the Metabase approach. Definitely look at: Awesome list of MetaBake resources https://git.mBake.org . In the next tutorial , we cover a view-model pattern . NEXT: Go to Simple CRUD example app and ViewModel+Bind .","title":"Generate a serverless CRUD webapp"},{"location":"crud/#generate-a-serverless-crud-webapp","text":"CRUD stands for create-read-update-delete. In this tutorial, you will learn how to create your own Firestore database. Firestore database is part of the Google Firestore offering. Similar to AWS Cognito, Firestore includes pure client-side user authentication. Firestore can be used from the browser via JavaScript; no custom serverside code is needed. This is key to be able to develop faster. Firestore is free for up to 50,000 reads and 20,000 writes per day. See more details here . At the time of writing, Firestore is a beta version, but Gmail also was beta for a very long time, without major issues. Firestore has a clean and mature API that is much improved from a previous version of Firebase.","title":"Generate a serverless CRUD webapp."},{"location":"crud/#steps","text":"Using the AWS S3 browser, create a bucket in the same region as you used in Setup S3 as your HTTP server and mount it . Name the bucket 'wgehner-crud' (replace 'wgehner' with your name or something else unique). Configure the bucket for static website hosting and apply the access policy analog to the 'website' project ( Step 4 ). Copy the Endpoint URL. The new bucket should appear as a new project root folder in your mapped drive (e.g. as W:\\wgehner-crud ). Extract the CRUD sample project to your computer with '$ mbake -v' and copy the project files (inside of /crud ) into the project root. In a browser, open the Endpoint URL. You should see the CRUD App served by S3. Navigate to the 'ViewModel CRUD' menu item. Inspect the fragment /screen/example1/index.pug . Note the table#table1 and table#table2 tags, an empty tables with ID #table1 and #table2 which fills with data using tabulator.js library. Next is how table is getting filled with data. getViewList('table1', 'table2') function is called from the bind file Example1Bind.js : getViewList(tableID, tableID2){ let _this = this let columns1 = [ //Define Table Columns {title:\"Col1\", field:\"col1\", align:\"left\", width:150}, {title:\"Col2\", field:\"col2\", align:\"left\", width:'70%'}, ]; let columns2 = [ //Define Table Columns {title:\"Col45\", field:\"col45\", align:\"left\", width:'70%'}, {title:\"Col55\", field:\"col55\", align:\"left\", width:'70%'}, ]; Promise.all([this.viewModel.read()]) .then(function(){ let data1 = _this.viewModel.getViewList(tableID) let data2 = _this.viewModel.getViewList(tableID2) _this.setTable(tableID, columns1, data1) _this.setTable(tableID2, columns2, data2) }) } then function this.viewModel.read() is called from the 'view-model' file assets/models/Example1ViewModel.js : read(){ let _this = this return Promise.all([this.exampleModel.read()]) .then(function(data){ _this._data = [].concat(data[0]) }) //maybe other read methods from a diffrent entity } and then this.exampleModel.read() function is called from assets/models/service/Example1Service.js : read(id?:string){ let _this = this console.info('--reading...', Date.now() - _start) let ref = db1.collection(this.entityName) if(id){ return db1.collection(this.entityName).doc(id) .get() .then(function(docSnap) { let temp = docSnap.data() temp['id'] = docSnap.id // Object.assign(_this._dataObj, temp) return temp }) .catch(function(error) { console.info(\"Error getting documents: \", error) }) } return ref .get() .then(function(querySnapshot) { let rows = [] querySnapshot.forEach(function(doc) { let row = doc.data() row['id'] = doc.id rows.push(row) }) return rows }) .catch(function(error) { console.info(\"Error getting documents: \", error) }) }//() it reads the data from the Firestore database and fills the table with the content. This is an example of a 'View-model' pattern. In View-model pattern each page should have a bind file and a ViewModel file. In bind file, eg Example1Bind.js , there is all that \u0441oncerns UI functionallity. In ViewModel file, eg: assets/models/Example1ViewModel.js there are the data samples 'real' or 'fake' which are then mapped with the data from the database in file assets/models/service/Example1Service.js in which create/read/update/delete functionallity directly occurs. Inspect /screen/auth/modA.pug the form that used here is styled with gridforms . If you will open screen/auth/modA.pug you can see this form. Here is the example of Firebase authentication. You can try to create user, reset password, sign-in and log out in browser on screen/auth page. The Firestore function to login with email and password: auth.signInWithEmailAndPassword(email,pswd) .then(function(user) { console.info(user) alert('Signed in successfully') //replace with pretty popup }) .catch(function(error){ console.info(error) alert(error) // replace with pretty popup }) the function to sign up a new user with email and password: auth.createUserWithEmailAndPassword(email,pswd) .then(function(user) { bAuth.sendEmailVerification() }) .catch(function(error){ console.info(error) //show error in .message alert(error) // replace with pretty popup }) the function that will sent reset password link to the user email: auth.sendPasswordResetEmail(email) and the function to log out: auth.signOut() all of them triggers on appropriate buttons click. To learn Firebase, you will now remap the Firestore connection to your own Firestore. Create a Google account if you don't already have one. Log into https://console.firebase.google.com . Create a project named test-crud . Under the left menu 'Develop - Database', create a Firestore app in test mode. On the Project Overview, click the </> button near 'Add an app to get started' to open a popup. In your mapped project /assets/comps/preRW-comp.pug , overwrite the values for apiKey, authDomain and projectId with the values shown in the Firestore popup and save. Run '$ mbake -t .' from the tags folder. ( /layout/layout.pug will use the updated script(src='/assets/comps/preRW-comp.min.js') .) We will now secure the database. In the Firestore Console, on the Rules tab in 'Develop - Database', replace: allow: read, write; with allow read, write: if request.auth.token.email_verified == true; Only logged in users who have been verified by email can now read from or write to the database. Since you are currently not logged in, 'Add data' on the 'CRUD' screen should now fail. We will now configure and test a sign-in method. In the Firestore Console, in 'Develop - Authentication', click on 'Set up sign-in method'. Enable Email/Password sign-up and save. In the CRUD App, navigate to the multi-purpose 'Auth' screen (/screen/auth/). Enter your email and a password and click the 'Sign Up' button. The new user should appear in the Firestore Authentication list of Users. Check your email and click on the link you received (The email can be customized on the Firestore Authentication Templates tab). Return to the Auth screen (/screen/auth/) and click the 'Sign In' button. If the login succeeded, 'Add row' on the 'View-Model CRUD' screen should now succeed, and you should see the added data in the Firestore database console. Summary: You learnt how to create your own Firestore database, insert data and add authentication to the app. Firestore replaces MongoDB, but also ORM, REST, DevOps, Security, Failover, etc. Instead of learning all of these, now you only need to learn how to use Firestore. That should create a huge savings in your development and operations budget. NEXT STEPS: You can try out more Template projects (type $ mbake ). You can also setup a META build server. META has a watcher that triggers 'mbake' when you save a file to a mapped drive. You can become 10X more productive by adopting the Metabase approach. Definitely look at: Awesome list of MetaBake resources https://git.mBake.org . In the next tutorial , we cover a view-model pattern . NEXT: Go to Simple CRUD example app and ViewModel+Bind .","title":"Steps"},{"location":"design/","text":"Design Design of UI is very important because it is the first thing that customer see on project (before the functionallity and code), so UI should be nice, at least neat, match colors, fonts, and shape of main controls and blocks on site. We use Spectre scss framework as default design UI, so you need to know Spectre well, which blocks and visual functionallity is has, to look when you'll get a task to do some block on real project. Also the UI should be responsive, Spectre has a section in the docs dedicated to the responsive layout. For more information on Spectre SCSS framework see Spectre docs In the next tutorial , we cover a blog website . NEXT: Go to Blog .","title":"Design"},{"location":"design/#design","text":"Design of UI is very important because it is the first thing that customer see on project (before the functionallity and code), so UI should be nice, at least neat, match colors, fonts, and shape of main controls and blocks on site. We use Spectre scss framework as default design UI, so you need to know Spectre well, which blocks and visual functionallity is has, to look when you'll get a task to do some block on real project. Also the UI should be responsive, Spectre has a section in the docs dedicated to the responsive layout. For more information on Spectre SCSS framework see Spectre docs In the next tutorial , we cover a blog website . NEXT: Go to Blog .","title":"Design"},{"location":"dynamic_data_binding/","text":"Learn serverless websites with dynamic databinding. A webapp is just a dynamic website. This tutorial helps you understand an example of a serverless website. Whether you plan to build a webapp or not, this tutorial is a good foundation. In this tutorial we cover these key concepts: appshell, includes, routes, custom tags, link lists, content lists, dependency management and serverless email. This includes dynamic databinding, where the browser ('client') uses data from a JSON response to dynamically render content client-side . We assume that you have already installed the example website project as described here ; generated with $ mbake -s and running on S3. Steps The example website uses an appshell for the parts of a website that are common to all pages. To understand how this works using Pug, inspect /zabout/about/index.pug and /get-started/index.pug . These Pug files show how the parts of the HTML they have in common are pulled from central places. Both pages use or 'extend' the template /layout/layout.pug . Open this template file, and see that it has 'blocks' named 'head2' , and 'main' . The Pug pages that extend this template define how to replace (or 'fill') these blocks. Each page defines that the 'main' block consists of a page-specific content. The website also makes use of Pug include . Looking at /zabout/contact/index.pug you see that the 'main' block includes fragment email.pug for the email form. We also can re-use email.pug anywhere else on page or in other pages. Now inspect /zabout/about/index.html . This is the complete HTML which mbake has collated together from template, fragments and dat.yaml. Since S3 returns the 'default' page index.html when the browser requests /zabout/about/ , this is what the end user sees. Application routes are defined with a href tags. Inspect /layout/navJBar.pug for examples. When a user clicks on a link, the URL in the browser changes and the respective content, such as /landing/why/index.html is returned. Users can bookmark individual URLs. The browser maintains a navigation history so that using its 'Back' button yields the expected result. We use Riot.js for custom tags. We use it when we need a new component or want to hide functions and vars. To learn how Riot components are written and used in Pug, inspect /riotFirst/comps/first-comp.pug . It looks something like this: first-comp p Dynamic Data: p { num } script. doSomething(arg) { console.info('arg: ', arg) this.update({num: arg}) } When 'doSomething()' gets called, it updates the {num} . You would run '$ mbake -t .' to generate a first-comp.js file to include in your page. mbake looks for files that end in '-comp.pug' . /riotFirst/index.pug uses this component and looks like this: head title #{title} body //- include Riot script(src='//cdn.jsdelivr.net/npm/riot@3.11.2/riot.min.js') //- include the component script script(src='tags/first-comp.min.js') p div //- use the tag first-comp script. var firstcomponent = riot.mount('first-comp')[0] // get the tag firstTag.doSomething(42) // call the logic You can see it working by going to /riotFirst/ in the browser. We can render a list of links from a list.json . Navigate to the 'News' menu item. Inspect /news/index.pug . We use Axios to load the JSON and our custom riot component table-comp to dynamically render the list of links in the browser. Note that we begin loading the JSON as early as possible, in parallel with the UI, so users have to wait less. Now inspect /news/tag/table-comp.pug and note the use of Pug each={items} with JavaScript to iterate through the items in list.json . You use '$ mbake -t .' to generate table-comp.js . It is incorporated in /news/index.pug . There's no need to write JSON by hand, as you can process a list.csv to list.json with '$ mbakeW -j .' . This is a great way to build lists that change over time. Inspect /assets/js/loader.js . We use a tiny dependency manager (862 bytes) to facilitate the loading of required libraries in parallel with the UI. Take another look at /zabout/contect/email.pug and the use of depp.require(['css'], setupEmail) . We use it to signal when an inline dependency has been met (a process is 'done' and code is 'ready' for execution). Finally, we use EmailJS to send email from the /zabout/contact page without any server code. Another feature of mbake allows you to generate an AMP version of a website that has no custom JavaScript. More about this in another upcoming tutorial. Summary : in this tutorial, you've learned about appshell, includes, routes, custom tags, link lists, content lists and serverless email, along with dynamic data binding. In the next tutorial , we cover a serverless CRUD webapp . NEXT: Go to Generate a serverless CRUD webapp .","title":"Dynamic databinding"},{"location":"dynamic_data_binding/#learn-serverless-websites-with-dynamic-databinding","text":"A webapp is just a dynamic website. This tutorial helps you understand an example of a serverless website. Whether you plan to build a webapp or not, this tutorial is a good foundation. In this tutorial we cover these key concepts: appshell, includes, routes, custom tags, link lists, content lists, dependency management and serverless email. This includes dynamic databinding, where the browser ('client') uses data from a JSON response to dynamically render content client-side . We assume that you have already installed the example website project as described here ; generated with $ mbake -s and running on S3.","title":"Learn serverless websites with dynamic databinding."},{"location":"dynamic_data_binding/#steps","text":"The example website uses an appshell for the parts of a website that are common to all pages. To understand how this works using Pug, inspect /zabout/about/index.pug and /get-started/index.pug . These Pug files show how the parts of the HTML they have in common are pulled from central places. Both pages use or 'extend' the template /layout/layout.pug . Open this template file, and see that it has 'blocks' named 'head2' , and 'main' . The Pug pages that extend this template define how to replace (or 'fill') these blocks. Each page defines that the 'main' block consists of a page-specific content. The website also makes use of Pug include . Looking at /zabout/contact/index.pug you see that the 'main' block includes fragment email.pug for the email form. We also can re-use email.pug anywhere else on page or in other pages. Now inspect /zabout/about/index.html . This is the complete HTML which mbake has collated together from template, fragments and dat.yaml. Since S3 returns the 'default' page index.html when the browser requests /zabout/about/ , this is what the end user sees. Application routes are defined with a href tags. Inspect /layout/navJBar.pug for examples. When a user clicks on a link, the URL in the browser changes and the respective content, such as /landing/why/index.html is returned. Users can bookmark individual URLs. The browser maintains a navigation history so that using its 'Back' button yields the expected result. We use Riot.js for custom tags. We use it when we need a new component or want to hide functions and vars. To learn how Riot components are written and used in Pug, inspect /riotFirst/comps/first-comp.pug . It looks something like this: first-comp p Dynamic Data: p { num } script. doSomething(arg) { console.info('arg: ', arg) this.update({num: arg}) } When 'doSomething()' gets called, it updates the {num} . You would run '$ mbake -t .' to generate a first-comp.js file to include in your page. mbake looks for files that end in '-comp.pug' . /riotFirst/index.pug uses this component and looks like this: head title #{title} body //- include Riot script(src='//cdn.jsdelivr.net/npm/riot@3.11.2/riot.min.js') //- include the component script script(src='tags/first-comp.min.js') p div //- use the tag first-comp script. var firstcomponent = riot.mount('first-comp')[0] // get the tag firstTag.doSomething(42) // call the logic You can see it working by going to /riotFirst/ in the browser. We can render a list of links from a list.json . Navigate to the 'News' menu item. Inspect /news/index.pug . We use Axios to load the JSON and our custom riot component table-comp to dynamically render the list of links in the browser. Note that we begin loading the JSON as early as possible, in parallel with the UI, so users have to wait less. Now inspect /news/tag/table-comp.pug and note the use of Pug each={items} with JavaScript to iterate through the items in list.json . You use '$ mbake -t .' to generate table-comp.js . It is incorporated in /news/index.pug . There's no need to write JSON by hand, as you can process a list.csv to list.json with '$ mbakeW -j .' . This is a great way to build lists that change over time. Inspect /assets/js/loader.js . We use a tiny dependency manager (862 bytes) to facilitate the loading of required libraries in parallel with the UI. Take another look at /zabout/contect/email.pug and the use of depp.require(['css'], setupEmail) . We use it to signal when an inline dependency has been met (a process is 'done' and code is 'ready' for execution). Finally, we use EmailJS to send email from the /zabout/contact page without any server code. Another feature of mbake allows you to generate an AMP version of a website that has no custom JavaScript. More about this in another upcoming tutorial. Summary : in this tutorial, you've learned about appshell, includes, routes, custom tags, link lists, content lists and serverless email, along with dynamic data binding. In the next tutorial , we cover a serverless CRUD webapp . NEXT: Go to Generate a serverless CRUD webapp .","title":"Steps"},{"location":"model/","text":"Simple CRUD example app and ViewModel+Bind ViewModel A ViewModel maps to a page/screen. A ViewModel should be named after a page and each page should have a ViewModel. (Rarely a page has 2 ViewModels, for example if there is a Tag/Component that is on more than one page/screen that has it's own ViewModel) So if there is a table in the screen/page, the ViewModel would have a public property of an array or such. If there is a form, the ViewModel would have a public property of an object that has the fields_names that map form_input_names. And if there are 2 tables and two form, then the ViewModel has 2 public arrays and 2 public objects. So binding is easy. And each ViewModel should be discreet. The CRUD and Fetch() that ViewModel is just plumbing. 98% of VideModel is mapping it to a view(pug) page|screen. CRUD stands for create-read-update-delete. These are the basic operations that a simple web app would be designed to achieve. After you will create simple CRUD app you will create your own Firestore database, insert data and add authentication to the app. Firestore is Firebase\u2019s new database. It\u2019s designed to store and sync app data at global scale easily. It\u2019s a managed NoSQL document-oriented database for mobile and web development. Firestore includes pure client-side user authentication and can be used from the browser via JavaScript. No custom serverside code is needed. This is key to be able to develop faster. You will need to learn about http://tabulator.info/ which allows you to create interactive tables in seconds from any HTML Table, JavaScript Array, AJAX data source or JSON formatted data. Steps for creating simple CRUD app For an example dynamic web app CRUD in console type: $ mbake -v This command will extract the CRUD sample project to your computer. If you are using S3 buckets you can copy the project files (inside of /crud) into the project root, so in a browser you should see the CRUD App served by S3 with your endpoint URL Navigate to the 'Tabu' menu item and inspect the fragment /tabu/list.pug. Note the #example-table component and the new Tabulator() function that converts the table into a datatable with headers and data. ViewModel+Bind Separate the UI from data ViewModel is a great way of organizing your code, so each section of your code has a purpose, and those purposes are different. There is a 'models' folder inside assets, where we describe each class/model without UI, its typescript. The models do the heavy lifting, eg: call the service and prepare data in a way that is needed for the View and Pug. To compile the changes in the typescript file, do the command from the 'models' folder: $ tsc Each page will have its own binding class eg: screen/example1/Example1Bind.js where we do data binding there is no calls to Model classes from the pages. If you want to get any data, you need to create Binding class in the same folder, and from there make a call to the Model class. In the next tutorial , we cover 6 fundamental elements of design . NEXT: Go to 6 fundamental elements of design .","title":"Simple CRUD example app and ViewModel+Bind"},{"location":"model/#simple-crud-example-app-and-viewmodelbind","text":"","title":"Simple CRUD example app and ViewModel+Bind"},{"location":"model/#viewmodel","text":"A ViewModel maps to a page/screen. A ViewModel should be named after a page and each page should have a ViewModel. (Rarely a page has 2 ViewModels, for example if there is a Tag/Component that is on more than one page/screen that has it's own ViewModel) So if there is a table in the screen/page, the ViewModel would have a public property of an array or such. If there is a form, the ViewModel would have a public property of an object that has the fields_names that map form_input_names. And if there are 2 tables and two form, then the ViewModel has 2 public arrays and 2 public objects. So binding is easy. And each ViewModel should be discreet. The CRUD and Fetch() that ViewModel is just plumbing.","title":"ViewModel"},{"location":"model/#98-of-videmodel-is-mapping-it-to-a-viewpug-pagescreen","text":"CRUD stands for create-read-update-delete. These are the basic operations that a simple web app would be designed to achieve. After you will create simple CRUD app you will create your own Firestore database, insert data and add authentication to the app. Firestore is Firebase\u2019s new database. It\u2019s designed to store and sync app data at global scale easily. It\u2019s a managed NoSQL document-oriented database for mobile and web development. Firestore includes pure client-side user authentication and can be used from the browser via JavaScript. No custom serverside code is needed. This is key to be able to develop faster. You will need to learn about http://tabulator.info/ which allows you to create interactive tables in seconds from any HTML Table, JavaScript Array, AJAX data source or JSON formatted data.","title":"98% of VideModel is mapping it to a view(pug) page|screen."},{"location":"model/#steps-for-creating-simple-crud-app","text":"For an example dynamic web app CRUD in console type: $ mbake -v This command will extract the CRUD sample project to your computer. If you are using S3 buckets you can copy the project files (inside of /crud) into the project root, so in a browser you should see the CRUD App served by S3 with your endpoint URL Navigate to the 'Tabu' menu item and inspect the fragment /tabu/list.pug. Note the #example-table component and the new Tabulator() function that converts the table into a datatable with headers and data.","title":"Steps for creating simple CRUD app"},{"location":"model/#viewmodelbind","text":"Separate the UI from data ViewModel is a great way of organizing your code, so each section of your code has a purpose, and those purposes are different. There is a 'models' folder inside assets, where we describe each class/model without UI, its typescript. The models do the heavy lifting, eg: call the service and prepare data in a way that is needed for the View and Pug. To compile the changes in the typescript file, do the command from the 'models' folder: $ tsc Each page will have its own binding class eg: screen/example1/Example1Bind.js where we do data binding there is no calls to Model classes from the pages. If you want to get any data, you need to create Binding class in the same folder, and from there make a call to the Model class. In the next tutorial , we cover 6 fundamental elements of design . NEXT: Go to 6 fundamental elements of design .","title":"ViewModel+Bind"},{"location":"npm/","text":"How to install mbake with NPM The simplest way to install mbake is using Yarn. But if you use some additional flags, you can use NPM instead. NPM needs the extra flags to be able to install Electron. Electron is used for the watcher (mbake -w). From a command line such as PowerShell, type: npm i -g mbake --unsafe-perm=true --allow-root That's it! If you don't have Node with NPM installed, first go here for Windows or here for MAC .","title":"Npm"},{"location":"npm/#how-to-install-mbake-with-npm","text":"The simplest way to install mbake is using Yarn. But if you use some additional flags, you can use NPM instead. NPM needs the extra flags to be able to install Electron. Electron is used for the watcher (mbake -w). From a command line such as PowerShell, type: npm i -g mbake --unsafe-perm=true --allow-root That's it! If you don't have Node with NPM installed, first go here for Windows or here for MAC .","title":"How to install mbake with NPM"},{"location":"pug_static_data/","text":"Learn Templating/Pug and static binding; view via S3 HTTP server. Simply said, Pug is HTML without closing tags. Pug is a templating language, more powerful than Markdown . If you know Node/Express, you know Pug already. If you know HTML, you also mostly know Pug: just don't close the tags. Pug also has variables (e.g. #{key1} ) and imports (e.g. include fragment.pug ). This Pug: header body p Hello #{key1} with key1:World (from dat.yaml in our case) becomes this HTML: <header></header> <body> <p> Hello World</p> </body> Pug is more concise, more powerful and easier to read and write than HTML. With Pug, you can also change the layout of your app; which is hard to do in Markdown. Because Markdown is useful for integrating larger bodies of text into HTML, mbake also supports include:metaMD mytext.md in Pug. We see Pug as a declarative 4th generation language (4GL). As we went from second generation assembly language (2GL) to higher level third generation (3GL, like C, C#, Java and JavaScript), our productivity jumped. Pug 4GL gets you to yet higher levels of productivity. Steps We assume that you have already installed mbake with $ yarn global add mbake as described here . Watch Do you even Jade bro as an intro about Pug (it used to be called Jade). Generate a sample website with $ mbake -s and copy the contents of the generated website folder to the bucket you mapped in Tutorial 1 , e.g. W:\\wgehner-website . Open this as a project in your favorite code editor (we like VS Code). In the Amazon S3 browser, go to the /assets/css folder, check all CSS files, select 'More - change metadata', and set 'Content-type' to text/css . View the app in a browser. Use the S3 URL from Tutorial 1 . For production, you can mask the URL with a proper domain with HTTPS by using a CDN. On the website, navigate to the /zabout/about/ page. In your code editor, go to the /zabout/about/ folder, edit dat.yaml and change 'About Us' to 'About Me' , save, then $ mbake . and refresh the browser. Of course you could also change something in index.pug . You can also use mbake live reload/watcher/compiler from the root folder of your project, this command will automatically compile .pug to .html and *-comp.pug to *-comp.js , and also scss/sass to css: $ mbakeW -w . About dat.yaml mbake looks for dat.yaml in each folder and uses it for static binding. If you have 'bla: Oh hi' in dat.yaml , you can use the value inside a .pug file at compile time via: #{bla} That will put 'Oh hi' , the value of bla at compile time, into the HTML. This is especially useful for any SEO items that can be repetitive in the HTML source. Summary : In this tutorial, you learnt about Pug and static data binding. In the next tutorial , we cover spectre css framework and scss . NEXT: Go to Spectre SCSS Theme Framework and SCSS .","title":"Learn Templating/Pug"},{"location":"pug_static_data/#learn-templatingpug-and-static-binding-view-via-s3-http-server","text":"Simply said, Pug is HTML without closing tags. Pug is a templating language, more powerful than Markdown . If you know Node/Express, you know Pug already. If you know HTML, you also mostly know Pug: just don't close the tags. Pug also has variables (e.g. #{key1} ) and imports (e.g. include fragment.pug ). This Pug: header body p Hello #{key1} with key1:World (from dat.yaml in our case) becomes this HTML: <header></header> <body> <p> Hello World</p> </body> Pug is more concise, more powerful and easier to read and write than HTML. With Pug, you can also change the layout of your app; which is hard to do in Markdown. Because Markdown is useful for integrating larger bodies of text into HTML, mbake also supports include:metaMD mytext.md in Pug. We see Pug as a declarative 4th generation language (4GL). As we went from second generation assembly language (2GL) to higher level third generation (3GL, like C, C#, Java and JavaScript), our productivity jumped. Pug 4GL gets you to yet higher levels of productivity.","title":"Learn Templating/Pug and static binding; view via S3 HTTP server."},{"location":"pug_static_data/#steps","text":"We assume that you have already installed mbake with $ yarn global add mbake as described here . Watch Do you even Jade bro as an intro about Pug (it used to be called Jade). Generate a sample website with $ mbake -s and copy the contents of the generated website folder to the bucket you mapped in Tutorial 1 , e.g. W:\\wgehner-website . Open this as a project in your favorite code editor (we like VS Code). In the Amazon S3 browser, go to the /assets/css folder, check all CSS files, select 'More - change metadata', and set 'Content-type' to text/css . View the app in a browser. Use the S3 URL from Tutorial 1 . For production, you can mask the URL with a proper domain with HTTPS by using a CDN. On the website, navigate to the /zabout/about/ page. In your code editor, go to the /zabout/about/ folder, edit dat.yaml and change 'About Us' to 'About Me' , save, then $ mbake . and refresh the browser. Of course you could also change something in index.pug . You can also use mbake live reload/watcher/compiler from the root folder of your project, this command will automatically compile .pug to .html and *-comp.pug to *-comp.js , and also scss/sass to css: $ mbakeW -w .","title":"Steps"},{"location":"pug_static_data/#about-datyaml","text":"mbake looks for dat.yaml in each folder and uses it for static binding. If you have 'bla: Oh hi' in dat.yaml , you can use the value inside a .pug file at compile time via: #{bla} That will put 'Oh hi' , the value of bla at compile time, into the HTML. This is especially useful for any SEO items that can be repetitive in the HTML source. Summary : In this tutorial, you learnt about Pug and static data binding. In the next tutorial , we cover spectre css framework and scss . NEXT: Go to Spectre SCSS Theme Framework and SCSS .","title":"About dat.yaml"},{"location":"res/","text":"Awesome low-code list of MetaBake resources https://github.com/metabake/MetaBake-Docs/tree/master/awesomeReference","title":"Resources"},{"location":"res/#awesome-low-code-list-of-metabake-resources","text":"https://github.com/metabake/MetaBake-Docs/tree/master/awesomeReference","title":"Awesome low-code list of MetaBake resources"},{"location":"s3_n_webdrive_mount/","text":"Create linux machine, install Caddy with webDAV and mount folder from linux machine to your PC via Mountain Duck mbake is Cloud v2.0. You do not need to install or maintain any HTTP, DB or any other server. Steps Setup up a Linux box in the cloud, e.g. Digital Ocean . Change the root password for DO linux box. Connect by ssh in terminal. It will ask to enter existing password and then new password: $ ssh root@[IP-Address] Setup a Web IDE account, e.g. CodeAnywhere online text editor (hereafter CA) In CA, connect to the Linux box. In CA, open SSH to the Linux box. Install yarn, mbake, typescript On Linux machine, install Caddy with webDAV plugin, eg: $ curl https://getcaddy.com | bash -s personal http.webdav Add Caddyfile to the root folder and config it, eg: :8080 { #cdn would go to this root /root/www gzip mime .css text/css # set user for the /webdav path basicauth /webdav admin 123123 webdav /webdav log ../log1 errors ../err1 } Create folder www and in this folder download blog source: $ mkdir www $ cd www $ mbake -b compile files: $ mbake -c . $ cd assets $ mbakeW -s . $ cd .. $ cd blog $ mbake -i . Run Caddy server, from the root folder where Caddyfile is: $ caddy -conf Caddyfile // or $ caddy // or (to leave caddy server running after you'll quit the terminal or close the CA tab) & nohup caddy & In browser open: http://157.230.189.157:8080/webdav login with login and password from Caddyfile and go to url, it should show your site from www folder: http://157.230.189.157:8080/ Install on Mac Mountain Duck you may choose a different webDAV mount software. Mount replaces FTP. In Mountain Duck, create a new webDAV (HTTP) connection. Fill the fields for server and username , path -- /webdav/www then click connect , it will ask for username and password enter the username and password from Caddyfile. The mounted folder will open in Finder. Now you have mounted folder of your site from linux machine on your local PC and you can edit it. Create an account on CDN77 if you don't already have one. Go to CDN 77 and create a resource for your linux machine: select My Origin and in the domain field type in the ip address of your linux machine To verify that the mount is working, you can edit some file and check if changes applied in the browser via the Endpoint URL from your recently created CDN Resource. Summary : With Cloud hosting and mount, you can edit apps from your filesystem and see the edits reflected on the web without extra deployment work. In the next tutorial you will learn how to mount folder from Linux box to another linux box via CodeAnywhere. NEXT: Go to Mount linux box folder to another linux box using CodeAnywhere editor .","title":"Create linux machine, install Caddy with webDAV and mount folder from linux machine to your PC via Mountain Duck"},{"location":"s3_n_webdrive_mount/#create-linux-machine-install-caddy-with-webdav-and-mount-folder-from-linux-machine-to-your-pc-via-mountain-duck","text":"mbake is Cloud v2.0. You do not need to install or maintain any HTTP, DB or any other server.","title":"Create linux machine, install Caddy with webDAV and mount folder from linux machine to your PC via Mountain Duck"},{"location":"s3_n_webdrive_mount/#steps","text":"Setup up a Linux box in the cloud, e.g. Digital Ocean . Change the root password for DO linux box. Connect by ssh in terminal. It will ask to enter existing password and then new password: $ ssh root@[IP-Address] Setup a Web IDE account, e.g. CodeAnywhere online text editor (hereafter CA) In CA, connect to the Linux box. In CA, open SSH to the Linux box. Install yarn, mbake, typescript On Linux machine, install Caddy with webDAV plugin, eg: $ curl https://getcaddy.com | bash -s personal http.webdav Add Caddyfile to the root folder and config it, eg: :8080 { #cdn would go to this root /root/www gzip mime .css text/css # set user for the /webdav path basicauth /webdav admin 123123 webdav /webdav log ../log1 errors ../err1 } Create folder www and in this folder download blog source: $ mkdir www $ cd www $ mbake -b compile files: $ mbake -c . $ cd assets $ mbakeW -s . $ cd .. $ cd blog $ mbake -i . Run Caddy server, from the root folder where Caddyfile is: $ caddy -conf Caddyfile // or $ caddy // or (to leave caddy server running after you'll quit the terminal or close the CA tab) & nohup caddy & In browser open: http://157.230.189.157:8080/webdav login with login and password from Caddyfile and go to url, it should show your site from www folder: http://157.230.189.157:8080/ Install on Mac Mountain Duck you may choose a different webDAV mount software. Mount replaces FTP. In Mountain Duck, create a new webDAV (HTTP) connection. Fill the fields for server and username , path -- /webdav/www then click connect , it will ask for username and password enter the username and password from Caddyfile. The mounted folder will open in Finder. Now you have mounted folder of your site from linux machine on your local PC and you can edit it. Create an account on CDN77 if you don't already have one. Go to CDN 77 and create a resource for your linux machine: select My Origin and in the domain field type in the ip address of your linux machine To verify that the mount is working, you can edit some file and check if changes applied in the browser via the Endpoint URL from your recently created CDN Resource. Summary : With Cloud hosting and mount, you can edit apps from your filesystem and see the edits reflected on the web without extra deployment work. In the next tutorial you will learn how to mount folder from Linux box to another linux box via CodeAnywhere. NEXT: Go to Mount linux box folder to another linux box using CodeAnywhere editor .","title":"Steps"},{"location":"spectre_n_scss/","text":"Spectre SCSS Theme Framework and SCSS Spectre The default SCSS theme framework used in most examples is Spectre CSS . Spectre is small (~10KB) but fully featured and easy to use. Spectre does not use JavaScript, which makes it AMP-compatible - a big plus for content-driven sites and apps. SCSS SCSS is the same as css, but what's more is that in scss there are supports nested elements, eg(from spectre _accordions.scss): .accordion-header { display: block; padding: $unit-1 $unit-2; .icon { transition: transform .25s; } } Also in scss there are available variables, as you can see from the previous example $unit-1 $unit-2 , and mixins \u2014 the parts of scss code that can be reused in other scss files or properties. The main scss differences from usual css are: nested elements variables mixins assets.yaml In our project we use mbake scss compiler, it works through assets.yaml eg: - https://github.com/metabake/MetaBake-Docs/tree/master/meta-website/assets There is list of sass files in assets.yaml and it will compile to /assets/css folder. So you can just run the command from the 'assets' folder to compile scss/sass to css: $ mbakeW -s . or any path in assets or any sub folder under assets and it will compile scss/sass to css. It won't work for folders other than /assets, or if there is no assets.yaml properly configured in assets. You can also use mbake live reload/watcher/compiler from the root folder of your project, this command will automatically compile scss/sass to css as well as .pug to .html , and *-comp.pug to *-comp.js . The command is: $ mbakeW -w . In the next tutorial , we cover dynamic databinding . Learn more about SCSS ans SASS here NEXT: Go to dynamic databinding .","title":"Spectre SCSS Theme Framework and SCSS"},{"location":"spectre_n_scss/#spectre-scss-theme-framework-and-scss","text":"","title":"Spectre SCSS Theme Framework and SCSS"},{"location":"spectre_n_scss/#spectre","text":"The default SCSS theme framework used in most examples is Spectre CSS . Spectre is small (~10KB) but fully featured and easy to use. Spectre does not use JavaScript, which makes it AMP-compatible - a big plus for content-driven sites and apps.","title":"Spectre"},{"location":"spectre_n_scss/#scss","text":"SCSS is the same as css, but what's more is that in scss there are supports nested elements, eg(from spectre _accordions.scss): .accordion-header { display: block; padding: $unit-1 $unit-2; .icon { transition: transform .25s; } } Also in scss there are available variables, as you can see from the previous example $unit-1 $unit-2 , and mixins \u2014 the parts of scss code that can be reused in other scss files or properties. The main scss differences from usual css are: nested elements variables mixins","title":"SCSS"},{"location":"spectre_n_scss/#assetsyaml","text":"In our project we use mbake scss compiler, it works through assets.yaml eg: - https://github.com/metabake/MetaBake-Docs/tree/master/meta-website/assets There is list of sass files in assets.yaml and it will compile to /assets/css folder. So you can just run the command from the 'assets' folder to compile scss/sass to css: $ mbakeW -s . or any path in assets or any sub folder under assets and it will compile scss/sass to css. It won't work for folders other than /assets, or if there is no assets.yaml properly configured in assets. You can also use mbake live reload/watcher/compiler from the root folder of your project, this command will automatically compile scss/sass to css as well as .pug to .html , and *-comp.pug to *-comp.js . The command is: $ mbakeW -w . In the next tutorial , we cover dynamic databinding . Learn more about SCSS ans SASS here NEXT: Go to dynamic databinding .","title":"assets.yaml"}]}