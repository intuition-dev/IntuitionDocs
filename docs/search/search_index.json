{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is mbake? mbake is a modern CLI static app generation tool. Apps and sites you generate with mbake are extreme serverless, allow user authentication and work with JSON and database APIs for dynamic databinding. You can use mbake for simple blogs or sites to the most complex web and mobile app projects. If you don't have time, see tl;dr at the bottom of this page. mbake compares to other static generators and grunt/gulp; but it does a lot more with a lot less coding. mbake is part of the MetaBake approach but can be used by itself. What is MetaBake? MetaBake is a modern development approach that helps you deliver web apps 10X faster with less coding. MetaBake has 10 pillars. Find out more about MetaBake: Quick Demo Meetup Video Slide Deck Summary for Managers MetaBake allows for gradual adoption. You can start by adopting just one or a few of its pillars. mbake is a good start. MetaBake and mbake are open source. The source code is available at github.com/MetaBake See Resources for related projects. How to install mbake From a command line such as PowerShell, type: yarn global add mbake That's it! If you don't have Yarn installed, first go here . How to create a Hello World app with mbake ## Create index.pug header body p Hello #{key1} ## Create dat.yaml key1: World ## Generate index.html from Pug and Yaml: mbake . or: mbake subfoldername Auto-build/generate: if you are using a MetaBake META build server (see META doc), you don't even have to do the 'mbake .'. META has a watcher that triggers 'mbake' when you save a file. How to run an mbake app (such as Hello World) mbake apps run on any static web server. This includes low-cost cloud hosting such as Amazon S3. We show how to work with S3 later in this doc. When you develop locally, you could use 'Web Server for Chrome' to run mbake apps. To install it, open your Google Chrome web browser and install the 'Web Server for Chrome' app from here . Launch the app, click the 'Choose Folder' button and select the root folder of your app (e.g. where index.html of your Hello World app is). Also ensure 'Options' has 'Automatically show index.html' checked. Ensure the Web Server is STARTED, then navigate to the proposed URL (e.g. http://127.0.0.1:8887). Even though mbake apps are installed on a static server, they are dynamic because they allow user authentication and work with JSON for dynamic rendering and and database APIs for dynamic databinding. How to generate a sample app with mbake ## Run mbake help to see the list of current sample apps mbake ## Generate sample app, e.g. mbake -c ## Navigate to it, e.g. cd crud Other popular mbake commands mbake -t . - Convert Pug/Riot files to useable tag/js, e.g.: data binding. mbake -i . - Convert dat.yaml static files to JSON, for dynamic binding. More about this in B-M-SPA docs. How to see all mbake options mbake How to make mbake apps serverless To go extreme serverless, we show how to use mbake with Amazon Web Services (AWS) S3 HTTP hosting Mounting software so you can mount AWS S3 as a drive Google Firebase/Firestore Go extreme serverless in four steps (Tutorials): Tutorial 1 : Setup S3 as your cloud server and mount it. Tutorial 2 : Learn Pug and static binding; view via S3 HTTP server. Tutorial 3 : Learn serverless websites with dynamic data binding. Tutorial 4 : Generate a serverless CRUD webapp. When done, you should see this . Serverless/Cloud V2, Mount and Pug are some of the pillars of MetaBake. tl;dr yarn global add mbake mbake mbake -c cd crud mbake . NEXT: Go to Tutorial 1 .","title":"Home"},{"location":"#what-is-mbake","text":"mbake is a modern CLI static app generation tool. Apps and sites you generate with mbake are extreme serverless, allow user authentication and work with JSON and database APIs for dynamic databinding. You can use mbake for simple blogs or sites to the most complex web and mobile app projects. If you don't have time, see tl;dr at the bottom of this page. mbake compares to other static generators and grunt/gulp; but it does a lot more with a lot less coding. mbake is part of the MetaBake approach but can be used by itself.","title":"What is mbake?"},{"location":"#what-is-metabake","text":"MetaBake is a modern development approach that helps you deliver web apps 10X faster with less coding. MetaBake has 10 pillars. Find out more about MetaBake: Quick Demo Meetup Video Slide Deck Summary for Managers MetaBake allows for gradual adoption. You can start by adopting just one or a few of its pillars. mbake is a good start. MetaBake and mbake are open source. The source code is available at github.com/MetaBake See Resources for related projects.","title":"What is MetaBake?"},{"location":"#how-to-install-mbake","text":"From a command line such as PowerShell, type: yarn global add mbake That's it! If you don't have Yarn installed, first go here .","title":"How to install mbake"},{"location":"#how-to-create-a-hello-world-app-with-mbake","text":"## Create index.pug header body p Hello #{key1} ## Create dat.yaml key1: World ## Generate index.html from Pug and Yaml: mbake . or: mbake subfoldername Auto-build/generate: if you are using a MetaBake META build server (see META doc), you don't even have to do the 'mbake .'. META has a watcher that triggers 'mbake' when you save a file.","title":"How to create a Hello World app with mbake"},{"location":"#how-to-run-an-mbake-app-such-as-hello-world","text":"mbake apps run on any static web server. This includes low-cost cloud hosting such as Amazon S3. We show how to work with S3 later in this doc. When you develop locally, you could use 'Web Server for Chrome' to run mbake apps. To install it, open your Google Chrome web browser and install the 'Web Server for Chrome' app from here . Launch the app, click the 'Choose Folder' button and select the root folder of your app (e.g. where index.html of your Hello World app is). Also ensure 'Options' has 'Automatically show index.html' checked. Ensure the Web Server is STARTED, then navigate to the proposed URL (e.g. http://127.0.0.1:8887). Even though mbake apps are installed on a static server, they are dynamic because they allow user authentication and work with JSON for dynamic rendering and and database APIs for dynamic databinding.","title":"How to run an mbake app (such as Hello World)"},{"location":"#how-to-generate-a-sample-app-with-mbake","text":"## Run mbake help to see the list of current sample apps mbake ## Generate sample app, e.g. mbake -c ## Navigate to it, e.g. cd crud","title":"How to generate a sample app with mbake"},{"location":"#other-popular-mbake-commands","text":"mbake -t . - Convert Pug/Riot files to useable tag/js, e.g.: data binding. mbake -i . - Convert dat.yaml static files to JSON, for dynamic binding. More about this in B-M-SPA docs.","title":"Other popular mbake commands"},{"location":"#how-to-see-all-mbake-options","text":"mbake","title":"How to see all mbake options"},{"location":"#how-to-make-mbake-apps-serverless","text":"To go extreme serverless, we show how to use mbake with Amazon Web Services (AWS) S3 HTTP hosting Mounting software so you can mount AWS S3 as a drive Google Firebase/Firestore","title":"How to make mbake apps serverless"},{"location":"#go-extreme-serverless-in-four-steps-tutorials","text":"Tutorial 1 : Setup S3 as your cloud server and mount it. Tutorial 2 : Learn Pug and static binding; view via S3 HTTP server. Tutorial 3 : Learn serverless websites with dynamic data binding. Tutorial 4 : Generate a serverless CRUD webapp. When done, you should see this . Serverless/Cloud V2, Mount and Pug are some of the pillars of MetaBake.","title":"Go extreme serverless in four steps (Tutorials):"},{"location":"#tldr","text":"yarn global add mbake mbake mbake -c cd crud mbake . NEXT: Go to Tutorial 1 .","title":"tl;dr"},{"location":"about/","text":"Click for 'THE' mbake Docs Low-code = 10X faster web app development. With MetaBake's modern development approach, it is not about replacing your tech stack with another tech stack -- it is about eliminating it! About MetaBake mBake.org is a development productivity suite. It should allow you to deliver 10 times faster then legacy development stacks/methodologies. We have found that - with mBake.org; - the work of 6 developers over 6 months can be done by 3 developers in 3 weeks. We expect you to achieve the same productivity gains. How does open source MetaBake deliver 10X faster and cheaper web app development? Not enough organizations are fully leveraging the new Serverless. With Serverless services like Firestore and S3 you get rid of ALL server-side and middleware development and operations. This is where up to 2/3 of your time and cost used to go. Gone! On the client side (browser apps and mobile apps) MetaBake does something similar: it eliminates much of the tech stack and reduces the amount of coding and complexity. How? In school textbooks you learned about 1st generation languages, 2nd generation languages and our current 3rd generation languages, such as JavaScript, PHP and Ruby. With each new generation we achieved huge productivity improvements. We consider 'Pug'--also used by Node/Express--a 4th generation language that helps gain an equally big jump in productivity. With MetaBake we show you how to build complete applications in Pug. With this Low-code approach we demonstrate much faster and cheaper web app and mobile app development. The MetaBake approach has 10 pillars that are the foundation for achieving mind-blowing development productivity gains. I'll just mention one more pillar here: automatic programming. You've probably heard of 'static site generators' like Hugo or Jekyll that people use to generate their web site or a blog. Automatic programming means using a similar generator to write your web app! This can get you to yet another level of productivity. To learn more about the MetaBake approach, including all 10 pillars and full examples, go to mBake.org. Or, to dive in right away, use the 'mbake CLI' from github.com/MetaBake as the first step into 10X faster web app development. mBake.org productivity is based on three modules: mbake, a static site generation tool that runs locally B-M-SPA, curated technologies and techniques that help you build dynamic apps and mobile apps faster Meta, a bespoke cloud-based build and admin app infrastructure that helps deliver functionality to your clients more quickly We benchmark against LAMP , RAILS , MEAN and such For example, LAMP is the technology WordPress was built on. Every 10 years or so technology gets 10 times better, which forces everyone to upgrade. Assembly was 10 times better than machine language. C/.js is 10 times better than Assembly. We believe that we found the answer on how to have a more productive team. So far, somehow, server-side rendered LAMP has dominated web deployments, with WordPress having some 30% of the World Wide Web. It is time to start displacing that. You can reinvest the time saved by using MetaBake into a more interactive user experience (UX). Better UX is proven to lead into higher user engagement and better user retention. About mbake mbake leverages the clarity, simplicity and productivity gained by using the declarative markup language Pug . We think of Pug as 4GL. mbake currently compiles Pug, Markdown and Yaml to generate HTML and JSON. Using the power of JavaScript, more transformers can be added. mbake runs as a small node process, either on your machine or in the cloud. mbake generates static sites, but it also supports making those sites dynamic with API calls and data feeds such as from JSON. mbake helps is another example of a http://staticgen.com webapp. mbake includes sample starters apps for CRUD. After you are comfortable with mbake, check out B-M-SPA and Meta. Prerequisites: you should know HTML and CSS. If you need to catch up, we recommend 'Design and Build Websites' by Jon Duckett. You will also learn Pug, to get started on Pug, watch Pug on Youtube Best way to get started with mbake is to read the Docs, linked at he top of the page.","title":"About"},{"location":"about/#low-code-10x-faster-web-app-development","text":"","title":"Low-code = 10X faster web app development."},{"location":"about/#with-metabakes-modern-development-approach-it-is-not-about-replacing-your-tech-stack-with-another-tech-stack-it-is-about-eliminating-it","text":"","title":"With MetaBake's modern development approach, it is not about replacing your tech stack with another tech stack -- it is about eliminating it!"},{"location":"about/#about-metabake","text":"mBake.org is a development productivity suite. It should allow you to deliver 10 times faster then legacy development stacks/methodologies. We have found that - with mBake.org; - the work of 6 developers over 6 months can be done by 3 developers in 3 weeks. We expect you to achieve the same productivity gains. How does open source MetaBake deliver 10X faster and cheaper web app development? Not enough organizations are fully leveraging the new Serverless. With Serverless services like Firestore and S3 you get rid of ALL server-side and middleware development and operations. This is where up to 2/3 of your time and cost used to go. Gone! On the client side (browser apps and mobile apps) MetaBake does something similar: it eliminates much of the tech stack and reduces the amount of coding and complexity. How? In school textbooks you learned about 1st generation languages, 2nd generation languages and our current 3rd generation languages, such as JavaScript, PHP and Ruby. With each new generation we achieved huge productivity improvements. We consider 'Pug'--also used by Node/Express--a 4th generation language that helps gain an equally big jump in productivity. With MetaBake we show you how to build complete applications in Pug. With this Low-code approach we demonstrate much faster and cheaper web app and mobile app development. The MetaBake approach has 10 pillars that are the foundation for achieving mind-blowing development productivity gains. I'll just mention one more pillar here: automatic programming. You've probably heard of 'static site generators' like Hugo or Jekyll that people use to generate their web site or a blog. Automatic programming means using a similar generator to write your web app! This can get you to yet another level of productivity. To learn more about the MetaBake approach, including all 10 pillars and full examples, go to mBake.org. Or, to dive in right away, use the 'mbake CLI' from github.com/MetaBake as the first step into 10X faster web app development.","title":"About MetaBake"},{"location":"about/#mbakeorg-productivity-is-based-on-three-modules","text":"mbake, a static site generation tool that runs locally B-M-SPA, curated technologies and techniques that help you build dynamic apps and mobile apps faster Meta, a bespoke cloud-based build and admin app infrastructure that helps deliver functionality to your clients more quickly We benchmark against LAMP , RAILS , MEAN and such For example, LAMP is the technology WordPress was built on. Every 10 years or so technology gets 10 times better, which forces everyone to upgrade. Assembly was 10 times better than machine language. C/.js is 10 times better than Assembly. We believe that we found the answer on how to have a more productive team. So far, somehow, server-side rendered LAMP has dominated web deployments, with WordPress having some 30% of the World Wide Web. It is time to start displacing that. You can reinvest the time saved by using MetaBake into a more interactive user experience (UX). Better UX is proven to lead into higher user engagement and better user retention.","title":"mBake.org productivity is based on three modules:"},{"location":"about/#about-mbake","text":"mbake leverages the clarity, simplicity and productivity gained by using the declarative markup language Pug . We think of Pug as 4GL. mbake currently compiles Pug, Markdown and Yaml to generate HTML and JSON. Using the power of JavaScript, more transformers can be added. mbake runs as a small node process, either on your machine or in the cloud. mbake generates static sites, but it also supports making those sites dynamic with API calls and data feeds such as from JSON. mbake helps is another example of a http://staticgen.com webapp. mbake includes sample starters apps for CRUD. After you are comfortable with mbake, check out B-M-SPA and Meta. Prerequisites: you should know HTML and CSS. If you need to catch up, we recommend 'Design and Build Websites' by Jon Duckett. You will also learn Pug, to get started on Pug, watch Pug on Youtube Best way to get started with mbake is to read the Docs, linked at he top of the page.","title":"About mbake"},{"location":"next/","text":"Next. Next steps would be the 'BM-SPA' or 'Meta' project, both are at git.mBake.org.","title":"Next Steps"},{"location":"next/#next","text":"Next steps would be the 'BM-SPA' or 'Meta' project, both are at git.mBake.org.","title":"Next."},{"location":"npm/","text":"How to install mbake with NPM The simplest way to install mbake is using Yarn. But if you use some additional flags, you can use NPM instead. NPM needs the extra flags to be able to install Electron. Electron is used for the watcher (mbake -w). From a command line such as PowerShell, type: npm i -g mbake --unsafe-perm=true --allow-root That's it! If you don't have Node with NPM installed, first go here for Windows or here for MAC .","title":"Npm"},{"location":"npm/#how-to-install-mbake-with-npm","text":"The simplest way to install mbake is using Yarn. But if you use some additional flags, you can use NPM instead. NPM needs the extra flags to be able to install Electron. Electron is used for the watcher (mbake -w). From a command line such as PowerShell, type: npm i -g mbake --unsafe-perm=true --allow-root That's it! If you don't have Node with NPM installed, first go here for Windows or here for MAC .","title":"How to install mbake with NPM"},{"location":"res/","text":"Awesome Low-code list of MetaBake resources https://github.com/metabake/MetaBake-Docs/tree/master/awesomeReference","title":"Resources"},{"location":"res/#awesome-low-code-list-of-metabake-resources","text":"https://github.com/metabake/MetaBake-Docs/tree/master/awesomeReference","title":"Awesome Low-code list of MetaBake resources"},{"location":"t1/","text":"Tutorial 1: Setup S3 as your HTTP server and mount it mbake is Cloud v2.0. You do not need to install or maintain any HTTP, DB or any other server. Steps [A detailed video of the following steps is available here .] Create an AWS account if you don't already have one. In AWS Menu 'Account - My Security Credentials', create a new Access Key , click 'Show Access Key', and copy it (to a file) for use below. (Advanced users can later use IAM instead.) Create an AWS S3 'bucket' in the \"US East (N Virginia)\" region. (Advanced users can select any region). Name the bucket 'wgehner-website' (replace wgehner with your name or something else unique). On the bucket Properties tab, select 'Static website hosting' and 'Use this bucket to host a website'. Copy the 'Endpoint URL' for use below. Once created, on the Detail Permissions tab, configure the access policy so that the bucket can be accessed via HTTP. Replace 'wgehner-website' with your bucket name. { \"Version\":\"2012-10-17\", \"Statement\": [{ \"Sid\":\"PublicReadGetObject\", \"Effect\":\"Allow\", \"Principal\": \"*\", \"Action\":[\"s3:GetObject\"], \"Resource\":[\"arn:aws:s3:::wgehner-website/*\" ] }] } Install Web Drive for Windows or on Mac Mountain Duck users may choose a different mount software. There are more than a dozen other choices ). Mount replaces FTP. In WebDrive, create a new Amazon S3 connection. Choose a drive letter (e.g. W:\\ ). Paste Access Key ID and Secret Access Key created in Step 1 above. If your bucket region is not \"US East (N Virginia)\", edit the S3 Account URL/Address to match the \"Endpoint URL' in this list . Example: change https://s3.amazonaws.com to https://s3.us-west-1.amazonaws.com if your region is US West (N. California). Do not select a specific bucket. This way all buckets for the region will show up as top level folders in the mounted drive, and your mounted drive letter effectively represents an S3 region in your AWS account. To verify that the mount is working, you can put an index.html into the mounted bucket project root (e.g. W:\\wgehner-website ) on your file system. You might just copy-paste the index.html you generated here . Then view it in the browser via the Endpoint URL copied in Step 3 above. Summary : With Cloud hosting and mount, you can edit apps from your filesystem and see the edits reflected on the web without extra deployment work. In the next tutorial you will learn about Pug and static data binding. NEXT: Go to Tutorial 2 .","title":"Tutorial 1 - Setup S3 and mount"},{"location":"t1/#tutorial-1-setup-s3-as-your-http-server-and-mount-it","text":"mbake is Cloud v2.0. You do not need to install or maintain any HTTP, DB or any other server.","title":"Tutorial 1: Setup S3 as your HTTP server and mount it"},{"location":"t1/#steps","text":"[A detailed video of the following steps is available here .] Create an AWS account if you don't already have one. In AWS Menu 'Account - My Security Credentials', create a new Access Key , click 'Show Access Key', and copy it (to a file) for use below. (Advanced users can later use IAM instead.) Create an AWS S3 'bucket' in the \"US East (N Virginia)\" region. (Advanced users can select any region). Name the bucket 'wgehner-website' (replace wgehner with your name or something else unique). On the bucket Properties tab, select 'Static website hosting' and 'Use this bucket to host a website'. Copy the 'Endpoint URL' for use below. Once created, on the Detail Permissions tab, configure the access policy so that the bucket can be accessed via HTTP. Replace 'wgehner-website' with your bucket name. { \"Version\":\"2012-10-17\", \"Statement\": [{ \"Sid\":\"PublicReadGetObject\", \"Effect\":\"Allow\", \"Principal\": \"*\", \"Action\":[\"s3:GetObject\"], \"Resource\":[\"arn:aws:s3:::wgehner-website/*\" ] }] } Install Web Drive for Windows or on Mac Mountain Duck users may choose a different mount software. There are more than a dozen other choices ). Mount replaces FTP. In WebDrive, create a new Amazon S3 connection. Choose a drive letter (e.g. W:\\ ). Paste Access Key ID and Secret Access Key created in Step 1 above. If your bucket region is not \"US East (N Virginia)\", edit the S3 Account URL/Address to match the \"Endpoint URL' in this list . Example: change https://s3.amazonaws.com to https://s3.us-west-1.amazonaws.com if your region is US West (N. California). Do not select a specific bucket. This way all buckets for the region will show up as top level folders in the mounted drive, and your mounted drive letter effectively represents an S3 region in your AWS account. To verify that the mount is working, you can put an index.html into the mounted bucket project root (e.g. W:\\wgehner-website ) on your file system. You might just copy-paste the index.html you generated here . Then view it in the browser via the Endpoint URL copied in Step 3 above. Summary : With Cloud hosting and mount, you can edit apps from your filesystem and see the edits reflected on the web without extra deployment work. In the next tutorial you will learn about Pug and static data binding. NEXT: Go to Tutorial 2 .","title":"Steps"},{"location":"t2/","text":"Tutorial 2: Learn Templating/Pug and static binding; view via S3 HTTP server. Simply said, Pug is HTML without closing tags. Pug is a templating language, more powerful than Markdown . If you know Node/Express, you know Pug already. If you know HTML, you also mostly know Pug: just don't close the tags. Pug also has variables (e.g. #{key1} ) and imports (e.g. include fragment.pug ). This Pug: header body p Hello #{key1} with key1:World (from dat.yaml in our case) becomes this HTML: header /header body p Hello World /p /body Pug is more concise, more powerful and easier to read and write than HTML. with Pug, you can also change the layout of your app; which is hard to do in Markdown. Because Markdown is useful for integrating larger bodies of text into HTML, mbake also supports include:markdown-it mytext.md in Pug. We see Pug as a declarative 4th generation language (4GL). As we went from second generation assembly language (2GL) to higher level third generation (3GL, like C, C#, Java and JavaScript), our productivity jumped. Pug 4GL gets you to yet higher levels of productivity. Steps We assume that you have already installed mbake with yarn global add mbake as described here . Watch Do you even Jade bro as an intro about Pug (it used to be called Jade). Generate a sample website with mbake -s and copy the contents of the generated website folder to the bucket you mapped in Tutorial 1 , e.g. W:\\wgehner-website . Open this as a project in your favorite code editor (we like VS Code). In the Amazon S3 browser, go to the /assets/css folder, check all CSS files, select 'More - change metadata', and set 'Content-type' to text/css . View the app in a browser. Use the S3 URL from Tutorial 1 , e.g. http://wgehner-website.s3-website-us-west-1.amazonaws.com . For production, you can mask the URL with a proper domain with HTTPS by using a CDN. You can find more detailed instructions here . On the website, navigate to the 'About Us' page. In your code editor, go to the /about/about folder, edit dat.yaml and change 'About Us' to 'About Me' , save, then 'mbake .' and refresh the browser. Of course you could also change something in index.pug . About dat.yaml mbake looks for dat.yaml in each folder and uses it for static binding. If you have 'bla: Oh hi' in dat.yaml , you can use the value inside a .pug file at compile time via: #{bla} That will put 'Oh hi' , the value of bla at compile time, into the HTML. This is especially useful for any SEO items that can be repetitive in the HTML source. Summary : In this tutorial, you learnt about Pug and static data binding. In the next tutorial , we cover websites with dynamic data binding . Default SCSS Theme Framework The default SCSS theme framework used in most examples is Spectre CSS , but you can use any CSS framework you like. Spectre is small (~10KB) but fully featured and easy to use. Spectre does not use JavaScript, which makes it AMP-compatible - a big plus for content-driven sites and apps. NEXT: Go to Tutorial 3 .","title":"Tutorial 2 - Learn Templating/Pug"},{"location":"t2/#tutorial-2-learn-templatingpug-and-static-binding-view-via-s3-http-server","text":"Simply said, Pug is HTML without closing tags. Pug is a templating language, more powerful than Markdown . If you know Node/Express, you know Pug already. If you know HTML, you also mostly know Pug: just don't close the tags. Pug also has variables (e.g. #{key1} ) and imports (e.g. include fragment.pug ). This Pug: header body p Hello #{key1} with key1:World (from dat.yaml in our case) becomes this HTML: header /header body p Hello World /p /body Pug is more concise, more powerful and easier to read and write than HTML. with Pug, you can also change the layout of your app; which is hard to do in Markdown. Because Markdown is useful for integrating larger bodies of text into HTML, mbake also supports include:markdown-it mytext.md in Pug. We see Pug as a declarative 4th generation language (4GL). As we went from second generation assembly language (2GL) to higher level third generation (3GL, like C, C#, Java and JavaScript), our productivity jumped. Pug 4GL gets you to yet higher levels of productivity.","title":"Tutorial 2: Learn Templating/Pug and static binding; view via S3 HTTP server."},{"location":"t2/#steps","text":"We assume that you have already installed mbake with yarn global add mbake as described here . Watch Do you even Jade bro as an intro about Pug (it used to be called Jade). Generate a sample website with mbake -s and copy the contents of the generated website folder to the bucket you mapped in Tutorial 1 , e.g. W:\\wgehner-website . Open this as a project in your favorite code editor (we like VS Code). In the Amazon S3 browser, go to the /assets/css folder, check all CSS files, select 'More - change metadata', and set 'Content-type' to text/css . View the app in a browser. Use the S3 URL from Tutorial 1 , e.g. http://wgehner-website.s3-website-us-west-1.amazonaws.com . For production, you can mask the URL with a proper domain with HTTPS by using a CDN. You can find more detailed instructions here . On the website, navigate to the 'About Us' page. In your code editor, go to the /about/about folder, edit dat.yaml and change 'About Us' to 'About Me' , save, then 'mbake .' and refresh the browser. Of course you could also change something in index.pug .","title":"Steps"},{"location":"t2/#about-datyaml","text":"mbake looks for dat.yaml in each folder and uses it for static binding. If you have 'bla: Oh hi' in dat.yaml , you can use the value inside a .pug file at compile time via: #{bla} That will put 'Oh hi' , the value of bla at compile time, into the HTML. This is especially useful for any SEO items that can be repetitive in the HTML source. Summary : In this tutorial, you learnt about Pug and static data binding. In the next tutorial , we cover websites with dynamic data binding .","title":"About dat.yaml"},{"location":"t2/#default-scss-theme-framework","text":"The default SCSS theme framework used in most examples is Spectre CSS , but you can use any CSS framework you like. Spectre is small (~10KB) but fully featured and easy to use. Spectre does not use JavaScript, which makes it AMP-compatible - a big plus for content-driven sites and apps. NEXT: Go to Tutorial 3 .","title":"Default SCSS Theme Framework"},{"location":"t3/","text":"Tutorial 3: Learn serverless websites with dynamic databinding. A webapp is just a dynamic website. This tutorial helps you understand an example of a serverless website. Whether you plan to build a webapp or not, this tutorial is a good foundation. In this tutorial we cover these key concepts: appshell, includes, routes, custom tags, link lists, content lists, dependency management and serverless email. This includes dynamic databinding, where the browser ('client') uses data from a JSON response to dynamically render content client-side . We assume that you have already installed the example website project as described here ; generated with mbake -s and running on S3. Steps The example website uses an appshell for the parts of a website that are common to all pages. To understand how this works using Pug, inspect /home/about/index.pug and /home/careers/index.pug . These Pug files show how the parts of the HTML they have in common are pulled from central places. Both pages use or 'extend' the template /layout/layout.pug . Open this template file, and see that it has 'blocks' named 'head2' , 'top' , and 'main' . The Pug pages that extend this template define how to replace (or 'fill') these blocks. For example, /home/about/index.pug defines that the 'head2' block consists of a page-specific 'title' tag. The website also makes use of Pug include . Looking at /home/about/index.pug you see that the 'top' block includes fragment /layout/nav.pug for the top menu navigation. We re-use nav.pug in /home/careers/index.pug and in other pages. Now inspect /home/about/index.html . This is the complete HTML which mbake has collated together from template, fragments and dat.yaml. Since S3 returns the 'default' page index.html when the browser requests /home/about/ , this is what the end user sees. Application routes are defined with a href tags. Inspect /layout/nav.pug for examples. When a user clicks on a link, the URL in the browser changes and the respective content, such as /home/about/index.html is returned. Users can bookmark individual URLs. The browser maintains a navigation history so that using its 'Back' button yields the expected result. We use Riot.js for custom tags. We use it when we need a new tag or want to hide functions and vars. To learn how Riot tags are written and used in Pug, inspect /riotFirst/tags/first-tag.pug . It looks something like this: first-tag p Dynamic Data: p { num } script. doSomething(arg) { console.info('arg: ', arg) this.update({num: arg}) } When 'doSomething()' gets called, it updates the {num} . You would run 'mbake -t .' to generate a first-tag.js file to include in your page. mbake looks for files that end in '-tag.pug' . /riotFirst/index.pug uses this tag and looks like this: head title #{title} body //- include Riot script(src='//cdn.jsdelivr.net/npm/riot@3.11.2/riot.min.js') //- include the tag script script(src='tags/first-tag.min.js') p div //- use the tag first-tag script. var firstTag = riot.mount('first-tag')[0] // get the tag firstTag.doSomething(42) // call the logic You can see it working by going to /riotFirst/ in the browser. We can render a list of links from a list.json . Navigate to the 'News' menu item. Inspect /news/index.pug . We use Axios to load the JSON and our custom riot tag table-tag to dynamically render the list of links in the browser. Note that we begin loading the JSON as early as possible, in parallel with the UI, so users have to wait less. Now inspect /news/tag/table-tag.pug and note the use of Pug each={items} with JavaScript to iterate through the items in list.json . You use 'mbake -t .' to generate table-tag.js . It is incorporated in /news/index.pug . There's no need to write JSON by hand, as you can process a list.csv to list.json with 'mbake -j .' . This is a great way to build lists that change over time. For more elaborate situations, such as with a blog or lists of content pages, we can generate a list from items placed in subfolders. Navigate to the 'Team' menu item. Inspect /team/index.pug . We use our custom card-tag to render a card for each team member, with the data necessary obtained from /team/items.json . We generated this JSON with 'mbake -i .' . This command loops through all the subfolders and aggregates the list of metadata (name and title) from dat.yaml in each subfolder. It adds a URL to the JSON items, with the root path prefix obtained from data_i.yaml . This is a great way to add or remove items from a website, where all necessary resources are located in a single folder for the item. You can generate an example blog app with mbake -b . Inspect /assets/js/setup.js . We use a tiny dependency manager (862 bytes) to facilitate the loading of required libraries in parallel with the UI. Take another look at /news/index.pug and the use of loadjs.done and loadjs.ready . We use loadjs to signal when an inline dependency has been met (a process is 'done' and code is 'ready' for execution). Finally, we use EmailJS to send email from the /contact page without any server code. Another feature of mbake allows you to generate an AMP version of a website that has no custom JavaScript. More about this in another upcoming tutorial. Summary : in this tutorial, you've learned about appshell, includes, routes, custom tags, link lists, content lists and serverless email, along with dynamic data binding. In the next tutorial , we cover a serverless CRUD webapp . NEXT: Go to Tutorial 4 .","title":"Tutorial 3 - Generate a website"},{"location":"t3/#tutorial-3-learn-serverless-websites-with-dynamic-databinding","text":"A webapp is just a dynamic website. This tutorial helps you understand an example of a serverless website. Whether you plan to build a webapp or not, this tutorial is a good foundation. In this tutorial we cover these key concepts: appshell, includes, routes, custom tags, link lists, content lists, dependency management and serverless email. This includes dynamic databinding, where the browser ('client') uses data from a JSON response to dynamically render content client-side . We assume that you have already installed the example website project as described here ; generated with mbake -s and running on S3.","title":"Tutorial 3: Learn serverless websites with dynamic databinding."},{"location":"t3/#steps","text":"The example website uses an appshell for the parts of a website that are common to all pages. To understand how this works using Pug, inspect /home/about/index.pug and /home/careers/index.pug . These Pug files show how the parts of the HTML they have in common are pulled from central places. Both pages use or 'extend' the template /layout/layout.pug . Open this template file, and see that it has 'blocks' named 'head2' , 'top' , and 'main' . The Pug pages that extend this template define how to replace (or 'fill') these blocks. For example, /home/about/index.pug defines that the 'head2' block consists of a page-specific 'title' tag. The website also makes use of Pug include . Looking at /home/about/index.pug you see that the 'top' block includes fragment /layout/nav.pug for the top menu navigation. We re-use nav.pug in /home/careers/index.pug and in other pages. Now inspect /home/about/index.html . This is the complete HTML which mbake has collated together from template, fragments and dat.yaml. Since S3 returns the 'default' page index.html when the browser requests /home/about/ , this is what the end user sees. Application routes are defined with a href tags. Inspect /layout/nav.pug for examples. When a user clicks on a link, the URL in the browser changes and the respective content, such as /home/about/index.html is returned. Users can bookmark individual URLs. The browser maintains a navigation history so that using its 'Back' button yields the expected result. We use Riot.js for custom tags. We use it when we need a new tag or want to hide functions and vars. To learn how Riot tags are written and used in Pug, inspect /riotFirst/tags/first-tag.pug . It looks something like this: first-tag p Dynamic Data: p { num } script. doSomething(arg) { console.info('arg: ', arg) this.update({num: arg}) } When 'doSomething()' gets called, it updates the {num} . You would run 'mbake -t .' to generate a first-tag.js file to include in your page. mbake looks for files that end in '-tag.pug' . /riotFirst/index.pug uses this tag and looks like this: head title #{title} body //- include Riot script(src='//cdn.jsdelivr.net/npm/riot@3.11.2/riot.min.js') //- include the tag script script(src='tags/first-tag.min.js') p div //- use the tag first-tag script. var firstTag = riot.mount('first-tag')[0] // get the tag firstTag.doSomething(42) // call the logic You can see it working by going to /riotFirst/ in the browser. We can render a list of links from a list.json . Navigate to the 'News' menu item. Inspect /news/index.pug . We use Axios to load the JSON and our custom riot tag table-tag to dynamically render the list of links in the browser. Note that we begin loading the JSON as early as possible, in parallel with the UI, so users have to wait less. Now inspect /news/tag/table-tag.pug and note the use of Pug each={items} with JavaScript to iterate through the items in list.json . You use 'mbake -t .' to generate table-tag.js . It is incorporated in /news/index.pug . There's no need to write JSON by hand, as you can process a list.csv to list.json with 'mbake -j .' . This is a great way to build lists that change over time. For more elaborate situations, such as with a blog or lists of content pages, we can generate a list from items placed in subfolders. Navigate to the 'Team' menu item. Inspect /team/index.pug . We use our custom card-tag to render a card for each team member, with the data necessary obtained from /team/items.json . We generated this JSON with 'mbake -i .' . This command loops through all the subfolders and aggregates the list of metadata (name and title) from dat.yaml in each subfolder. It adds a URL to the JSON items, with the root path prefix obtained from data_i.yaml . This is a great way to add or remove items from a website, where all necessary resources are located in a single folder for the item. You can generate an example blog app with mbake -b . Inspect /assets/js/setup.js . We use a tiny dependency manager (862 bytes) to facilitate the loading of required libraries in parallel with the UI. Take another look at /news/index.pug and the use of loadjs.done and loadjs.ready . We use loadjs to signal when an inline dependency has been met (a process is 'done' and code is 'ready' for execution). Finally, we use EmailJS to send email from the /contact page without any server code. Another feature of mbake allows you to generate an AMP version of a website that has no custom JavaScript. More about this in another upcoming tutorial. Summary : in this tutorial, you've learned about appshell, includes, routes, custom tags, link lists, content lists and serverless email, along with dynamic data binding. In the next tutorial , we cover a serverless CRUD webapp . NEXT: Go to Tutorial 4 .","title":"Steps"},{"location":"t4/","text":"Tutorial 4: Generate a serverless CRUD webapp. CRUD stands for create-read-update-delete. In this tutorial, you will learn how to create your own Firestore database, insert data and add authentication to the app. Alongside, you will learn to render lists using https://dataTables.net/ with advanced grid sorting, searching and paging. Firestore database is part of the Google Firestore offering. Similar to AWS Cognito, Firestore includes pure client-side user authentication. Firestore can be used from the browser via JavaScript; no custom serverside code is needed. This is key to be able to develop faster. Firestore is free for up to 50,000 reads and 20,000 writes per day. See more details here . At the time of writing, Firestore is a beta version, but Gmail also was beta for a very long time, without major issues. Firestore has a clean and mature API that is much improved from a previous version of Firebase. Steps We assume you have completed Tutorial 1 , Tutorial 2 and Tutorial 3 . Using the AWS S3 browser, create a bucket in the same region as you used in Tutorial 1 . Name the bucket 'wgehner-crud' (replace 'wgehner' with your name or something else unique). Configure the bucket for static website hosting and apply the access policy analog to the 'website' project ( Step 3 in Tutorial 1). Copy the Endpoint URL. The new bucket should appear as a new project root folder in your mapped drive (e.g. as W:\\wgehner-crud ). Extract the CRUD sample project to your computer with 'mbake -c' and copy the project files (inside of /crud ) into the project root. In a browser, open the Endpoint URL. You should see the CRUD App served by S3. Navigate to the 'DataTable' menu item. Inspect the fragment /datatable/list.pug . Note the table#list1 tag, an empty table with ID list1 , and the setupTable() function that converts the table into a datatable with headers, data and the default features of sorting, in-memory searching and paging. As a next step, navigate to the 'Live CRUD' menu item, and inspect the fragment /live/table.pug . This time, the function read(onData, onErr) in /assets/js/rw.js is responsible for loading the (live) data from a preconfigured Firestore. More about rw.js below. The onData handler in table.pug populates the datatable. To learn Firebase, you will now remap the Firestore connection to your own Firestore. Create a Google account if you don't already have one. Log into https://console.firebase.google.com . Create a project named test-crud . Under the left menu 'Develop - Database', create a Firestore app in test mode. On the Project Overview, click the / button near 'Add an app to get started' to open a popup. In your mapped project /layout/tags/preRW-tag.pug , overwrite the values for apiKey, authDomain and projectId with the values shown in the Firestore popup and save. Run 'mbake -t .' from the tags folder. ( /layout/layout.pug will use the updated script(src='/layout/tags/preRW-tag.min.js') .) In a browser, refresh the Live CRUD page. Inspect /screen/live/form.pug and see how the function setupForm() maps button click events to actions in our helper library /assets/js/rw.js . Back in the browser, enter some data in the form fields and click 'Add data'. Back in the Firestore Console, in 'Develop - Database', you should see the inserted data as first item in 'table_one'. Repeat to insert a second item. This form is styled with gridforms . This example uses js-signals to dispatch a row click event and fill the form with the row data. Look for dtSig.dispatch(row) in /screen/live/table.pug . Next inspect /assets/js/rw.js . Look for the function add(row, resolve, reject) that inserts data on button click. You will see something like this: let newPK = db1.collection(window.tablename).doc() // make PK newPK.set(newRow) // insert The JavaScript API of Firestore is intuitive and easy to use. We will now secure the database. In the Firestore Console, on the Rules tab in 'Develop - Database', replace allow: read, write; with allow read, write: if request.auth.token.email_verified == true ; Publish the change. Only logged in users who have been verified by email can now read from or write to the database. Since you are currently not logged in, 'Add data' on the 'CRUD' screen should now fail. We will now configure and test a sign-in method. In the Firestore Console, in 'Develop - Authentication', click on 'Set up sign-in method'. Enable Email/Password sign-up and save. In the CRUD App, navigate to the multi-purpose 'Auth' screen (/screen/auth/). Enter your email and a password and click the 'Sign Up' button. The new user should appear in the Firestore Authentication list of Users. Check your email and click on the link you received (The email can be customized on the Firestore Authentication Templates tab). Return to the Auth screen (/screen/auth/) and click the 'Sign In' button. If the login succeeded, 'Add data' on the 'Live CRUD' screen should now succeed, and you should see the added data in the Firestore database console. Summary: You learnt how to create your own Firestore database, insert data and add authentication to the app, along with using datatables. Firestore replaces MongoDB, but also ORM, REST, DevOps, Security, Failover, etc. Instead of learning all of these, now you only need to learn how to use Firestore . That should create a huge savings in your development and operations budget. NEXT STEPS: You can try out more Template projects (type mbake ). You can also setup a META build server. META has a watcher that triggers 'mbake' when you save a file to a mapped drive. You can become 10X more productive by adopting the Metabase approach. Definitely look at: Awesome list of MetaBake resources Advanced reference and examples https://git.mBake.org .","title":"Tutorial 4 - Generate a CRUD webapp"},{"location":"t4/#tutorial-4-generate-a-serverless-crud-webapp","text":"CRUD stands for create-read-update-delete. In this tutorial, you will learn how to create your own Firestore database, insert data and add authentication to the app. Alongside, you will learn to render lists using https://dataTables.net/ with advanced grid sorting, searching and paging. Firestore database is part of the Google Firestore offering. Similar to AWS Cognito, Firestore includes pure client-side user authentication. Firestore can be used from the browser via JavaScript; no custom serverside code is needed. This is key to be able to develop faster. Firestore is free for up to 50,000 reads and 20,000 writes per day. See more details here . At the time of writing, Firestore is a beta version, but Gmail also was beta for a very long time, without major issues. Firestore has a clean and mature API that is much improved from a previous version of Firebase.","title":"Tutorial 4: Generate a serverless CRUD webapp."},{"location":"t4/#steps","text":"We assume you have completed Tutorial 1 , Tutorial 2 and Tutorial 3 . Using the AWS S3 browser, create a bucket in the same region as you used in Tutorial 1 . Name the bucket 'wgehner-crud' (replace 'wgehner' with your name or something else unique). Configure the bucket for static website hosting and apply the access policy analog to the 'website' project ( Step 3 in Tutorial 1). Copy the Endpoint URL. The new bucket should appear as a new project root folder in your mapped drive (e.g. as W:\\wgehner-crud ). Extract the CRUD sample project to your computer with 'mbake -c' and copy the project files (inside of /crud ) into the project root. In a browser, open the Endpoint URL. You should see the CRUD App served by S3. Navigate to the 'DataTable' menu item. Inspect the fragment /datatable/list.pug . Note the table#list1 tag, an empty table with ID list1 , and the setupTable() function that converts the table into a datatable with headers, data and the default features of sorting, in-memory searching and paging. As a next step, navigate to the 'Live CRUD' menu item, and inspect the fragment /live/table.pug . This time, the function read(onData, onErr) in /assets/js/rw.js is responsible for loading the (live) data from a preconfigured Firestore. More about rw.js below. The onData handler in table.pug populates the datatable. To learn Firebase, you will now remap the Firestore connection to your own Firestore. Create a Google account if you don't already have one. Log into https://console.firebase.google.com . Create a project named test-crud . Under the left menu 'Develop - Database', create a Firestore app in test mode. On the Project Overview, click the / button near 'Add an app to get started' to open a popup. In your mapped project /layout/tags/preRW-tag.pug , overwrite the values for apiKey, authDomain and projectId with the values shown in the Firestore popup and save. Run 'mbake -t .' from the tags folder. ( /layout/layout.pug will use the updated script(src='/layout/tags/preRW-tag.min.js') .) In a browser, refresh the Live CRUD page. Inspect /screen/live/form.pug and see how the function setupForm() maps button click events to actions in our helper library /assets/js/rw.js . Back in the browser, enter some data in the form fields and click 'Add data'. Back in the Firestore Console, in 'Develop - Database', you should see the inserted data as first item in 'table_one'. Repeat to insert a second item. This form is styled with gridforms . This example uses js-signals to dispatch a row click event and fill the form with the row data. Look for dtSig.dispatch(row) in /screen/live/table.pug . Next inspect /assets/js/rw.js . Look for the function add(row, resolve, reject) that inserts data on button click. You will see something like this: let newPK = db1.collection(window.tablename).doc() // make PK newPK.set(newRow) // insert The JavaScript API of Firestore is intuitive and easy to use. We will now secure the database. In the Firestore Console, on the Rules tab in 'Develop - Database', replace allow: read, write; with allow read, write: if request.auth.token.email_verified == true ; Publish the change. Only logged in users who have been verified by email can now read from or write to the database. Since you are currently not logged in, 'Add data' on the 'CRUD' screen should now fail. We will now configure and test a sign-in method. In the Firestore Console, in 'Develop - Authentication', click on 'Set up sign-in method'. Enable Email/Password sign-up and save. In the CRUD App, navigate to the multi-purpose 'Auth' screen (/screen/auth/). Enter your email and a password and click the 'Sign Up' button. The new user should appear in the Firestore Authentication list of Users. Check your email and click on the link you received (The email can be customized on the Firestore Authentication Templates tab). Return to the Auth screen (/screen/auth/) and click the 'Sign In' button. If the login succeeded, 'Add data' on the 'Live CRUD' screen should now succeed, and you should see the added data in the Firestore database console. Summary: You learnt how to create your own Firestore database, insert data and add authentication to the app, along with using datatables. Firestore replaces MongoDB, but also ORM, REST, DevOps, Security, Failover, etc. Instead of learning all of these, now you only need to learn how to use Firestore . That should create a huge savings in your development and operations budget. NEXT STEPS: You can try out more Template projects (type mbake ). You can also setup a META build server. META has a watcher that triggers 'mbake' when you save a file to a mapped drive. You can become 10X more productive by adopting the Metabase approach. Definitely look at: Awesome list of MetaBake resources Advanced reference and examples https://git.mBake.org .","title":"Steps"}]}