{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About MetaBake 'All my friends KNOW the low-coder' MetaBake is the extensible open source low-code productivity tool for programmers; including dynamic apps and data binding. MetaBake mbake CLI tool is a modern way to generate websites and dynamic webapps via low-code to help you achieve high developer productivity, without additional effort. MetaBake open source tool helps you deliver web apps 10X faster with less coding by leveraging our documented high-productivity approaches/pillars. MetaBake is a simple tool, but can build any type of an app or website, and it allows for gradual adoption. You can start by slowly adopting just a few of its approaches. Prerequisites: you should know HTML, CSS an .js - that is all we use. If you need to catch up, we recommend this book: 'Design and Build Websites' by Jon Duckett. Install yarn global add mbake mbake MetaBake in 2 Minute: First Page Create a folder called 'one'. In the folder 'one', create file index.pug header body p Hello #{key1} and create file dat.yaml key1: World Note: to create a new page|screen in mbake, create a new folder with an index.pug and day.yaml in each folder. Now make with mbake: mbake . This will create index.html. Of course you can use regular Pug syntax to include other Pug files; or Markdown. (MetaBake Markdown flavor includes CSS support): body div include:metaMD comment.md And example Markdown file with CSS style # header {.style-me} I think this is good. So if you write a Markdown file comment.md; it will be included in index.html Watcher This will start a webserver and auto-refresh browser, and watch for file changes to auto build: mbakeX -w . Instead of . you can specify any path. Also, the fact that we are generating this static content allows us to have the entire webapp served by a CDN. SASS CSS can be hard to work with so people use Sass/Scss. Create a ex.sass file: $font-stack: Helvetica, sans-serif; $primary-color: #333; body { font: 100% $font-stack; color: $primary-color; } Create a files assets.yaml css: - ex.sass and run mbake -s . It will create a css file with auto-prefixes. TypeScript TypeScript is supper-set of JavaScript. Write a ts file, like foo.ts: foo(i:number) { console.log('oh hi') } and run mbake -t . It will create a .js and min.js files. It will output ES5 to support IE11, so feel free to use class { } syntax. If there is no .ts, than it will simply slightly mimifify js files into min.js (but no ES5 conversion). Examples - Website There are 12 very different examples included in the mbake CLI. One is just a website: mbake -w That will extract an example website in the current folder. ( Obviously you can create any layout with any combination of css and other libraries, but here is how we laid out an example/starter website). Dynamic data/CRUD/'ViewModel' This relates to dynamic data, not static content (static eg: CMS or eCommerce). To extract an example CRUD web-app in the current folder: mbake -u It has a README.md in root of the website that you can glance. Blog/Itemize example Itemize (eg Blog) Lets build a folder called Items and in that folder create create a blank file dat_i.yaml, with nothing there. In the folder called Items create folder Page1 and folder Page2. In each page folder create index.pug and dat.yaml. So you have Page1 and Page2 folder under items In each Page's dat.yaml add title: Page name And add a few more key/value words in each dat.yaml, but make each pages values a bit different. And now, in the folder Items run mbake -i . It will create items.json. This allows you to fetch that json; and search for content, blog, items, etc. mbake -b will emit an example blog with above. The example blog will also show you how the items.json is read to display a nice searchable and paginated list of items. No magic. mbake review, extras and next steps 'All my friends KNOW the low-coder' mbake is the open source modern tool for developers that makes you most productive: it makes Pug, SCSS and Typescript. It comes with example apps that include WebSite showing how to load.js, CRUD showing how to do dynamic apps. You can use any application architecture you like, but Also it you you can itemize (-i dat.yaml files) to make a nice SEO friendly blog. Extras and next steps Now that you know mbake foundation, here are some choices for next things to learn in the advanced docs, pick and chose: baseCMS: an admin panel that you can host to can use as is; or as a base to build commercial grade CMS or eCommerce site, including browser plugin. MetaCake: plugin components, makes it easy for designers to write real web-apps. Developed with RIOTjs, easier than Reactjs (commercial license optional) AMP SPA router: with page transition effects and state machine (needed for cross-platform development) Cross platform development with real single code base development: single code base for Web, AMP, Electron and PhoneGap/Crodova VS code from the Cloud: multiple developers using a browser against same VS Code host in the cloud Other examples include: - Using markdown CSS effect: allows non-programmers to write interactive stories - Slide show with markdown - Dashboard example - Ads example Links Click for mbake Docs: docs.MetaBake.org git.MetaBake.org Community forum.MetaBake.org Check for the latest version of mbake: npm.js","title":"Home/About"},{"location":"#about-metabake","text":"","title":"About MetaBake&trade;"},{"location":"#all-my-friends-know-the-low-coder","text":"","title":"'All my friends KNOW the low-coder'"},{"location":"#metabake-is-the-extensible-open-source-low-code-productivity-tool-for-programmers-including-dynamic-apps-and-data-binding","text":"MetaBake mbake CLI tool is a modern way to generate websites and dynamic webapps via low-code to help you achieve high developer productivity, without additional effort. MetaBake open source tool helps you deliver web apps 10X faster with less coding by leveraging our documented high-productivity approaches/pillars. MetaBake is a simple tool, but can build any type of an app or website, and it allows for gradual adoption. You can start by slowly adopting just a few of its approaches. Prerequisites: you should know HTML, CSS an .js - that is all we use. If you need to catch up, we recommend this book: 'Design and Build Websites' by Jon Duckett.","title":"MetaBake&trade; is the extensible open source low-code productivity tool for programmers; including dynamic apps and data binding."},{"location":"#install","text":"yarn global add mbake mbake","title":"Install"},{"location":"#metabake-in-2-minute","text":"","title":"MetaBake&trade; in 2 Minute:"},{"location":"#first-page","text":"Create a folder called 'one'. In the folder 'one', create file index.pug header body p Hello #{key1} and create file dat.yaml key1: World Note: to create a new page|screen in mbake, create a new folder with an index.pug and day.yaml in each folder.","title":"First Page"},{"location":"#now-make-with-mbake","text":"mbake . This will create index.html. Of course you can use regular Pug syntax to include other Pug files; or Markdown. (MetaBake Markdown flavor includes CSS support): body div include:metaMD comment.md And example Markdown file with CSS style # header {.style-me} I think this is good. So if you write a Markdown file comment.md; it will be included in index.html","title":"Now make with mbake:"},{"location":"#watcher","text":"This will start a webserver and auto-refresh browser, and watch for file changes to auto build: mbakeX -w . Instead of . you can specify any path. Also, the fact that we are generating this static content allows us to have the entire webapp served by a CDN.","title":"Watcher"},{"location":"#sass","text":"CSS can be hard to work with so people use Sass/Scss. Create a ex.sass file: $font-stack: Helvetica, sans-serif; $primary-color: #333; body { font: 100% $font-stack; color: $primary-color; } Create a files assets.yaml css: - ex.sass and run mbake -s . It will create a css file with auto-prefixes.","title":"SASS"},{"location":"#typescript","text":"TypeScript is supper-set of JavaScript. Write a ts file, like foo.ts: foo(i:number) { console.log('oh hi') } and run mbake -t . It will create a .js and min.js files. It will output ES5 to support IE11, so feel free to use class { } syntax. If there is no .ts, than it will simply slightly mimifify js files into min.js (but no ES5 conversion).","title":"TypeScript"},{"location":"#examples-website","text":"There are 12 very different examples included in the mbake CLI. One is just a website: mbake -w That will extract an example website in the current folder. ( Obviously you can create any layout with any combination of css and other libraries, but here is how we laid out an example/starter website).","title":"Examples - Website"},{"location":"#dynamic-datacrudviewmodel","text":"This relates to dynamic data, not static content (static eg: CMS or eCommerce). To extract an example CRUD web-app in the current folder: mbake -u It has a README.md in root of the website that you can glance.","title":"Dynamic data/CRUD/'ViewModel'"},{"location":"#blogitemize-example","text":"","title":"Blog/Itemize example"},{"location":"#itemize-eg-blog","text":"Lets build a folder called Items and in that folder create create a blank file dat_i.yaml, with nothing there. In the folder called Items create folder Page1 and folder Page2. In each page folder create index.pug and dat.yaml. So you have Page1 and Page2 folder under items In each Page's dat.yaml add title: Page name And add a few more key/value words in each dat.yaml, but make each pages values a bit different. And now, in the folder Items run mbake -i . It will create items.json. This allows you to fetch that json; and search for content, blog, items, etc.","title":"Itemize (eg Blog)"},{"location":"#mbake-b-will-emit-an-example-blog-with-above","text":"The example blog will also show you how the items.json is read to display a nice searchable and paginated list of items. No magic.","title":"mbake -b will emit an example blog with above."},{"location":"#mbake-review-extras-and-next-steps","text":"","title":"mbake review, extras and next steps"},{"location":"#all-my-friends-know-the-low-coder_1","text":"mbake is the open source modern tool for developers that makes you most productive: it makes Pug, SCSS and Typescript. It comes with example apps that include WebSite showing how to load.js, CRUD showing how to do dynamic apps. You can use any application architecture you like, but Also it you you can itemize (-i dat.yaml files) to make a nice SEO friendly blog.","title":"'All my friends KNOW the low-coder'"},{"location":"#extras-and-next-steps","text":"Now that you know mbake foundation, here are some choices for next things to learn in the advanced docs, pick and chose: baseCMS: an admin panel that you can host to can use as is; or as a base to build commercial grade CMS or eCommerce site, including browser plugin. MetaCake: plugin components, makes it easy for designers to write real web-apps. Developed with RIOTjs, easier than Reactjs (commercial license optional) AMP SPA router: with page transition effects and state machine (needed for cross-platform development) Cross platform development with real single code base development: single code base for Web, AMP, Electron and PhoneGap/Crodova VS code from the Cloud: multiple developers using a browser against same VS Code host in the cloud Other examples include: - Using markdown CSS effect: allows non-programmers to write interactive stories - Slide show with markdown - Dashboard example - Ads example","title":"Extras and next steps"},{"location":"#links","text":"Click for mbake Docs: docs.MetaBake.org git.MetaBake.org Community forum.MetaBake.org Check for the latest version of mbake: npm.js","title":"Links"},{"location":"SEO/","text":"SEO and social tags SEO Since the web-app with metabake is statically generated it is great a SEO. Of course coming up with keywords for your landing pages is hard work and outside the scope of this documentation. And you should register any website or blog with 'Google Webmasters search console': since it allows to instantly check that the page SEO is working. Otherwise you are waiting for weeks to just change some code. Make sure you submit the page you are working on to 'Google Webmasters search console' so you can see how the SEO sees it. Social SEO And we help with social SEO, eg: If your dat.yaml is like this: title: MetaBake trade; versus other Low-Code tools image: slide-3.jpg content_text: MetaBake trade; is the open source extensible low-code productivity tool for programmers. keywords: low-code, gulp, grunt, CMS, static gen Then you can do social SEO like this - for example in your head.pug that you include in your pages or layouts: title #{title} meta(name='description', content=content_text) meta(name= google-site-verification , content= xyz ) // Twitter Card data meta(name='twitter:card', content='summary_large_image') meta(name='twitter:title', content=title) meta(name='twitter:description', content=content_text) meta(name='twitter:image', content=image) // Open Graph data meta(property='og:title', content=title) meta(property='og:type', content='article') meta(property='og:image', content=image) meta(property='og:description', content=comment)","title":"SEO and social tags SEO"},{"location":"SEO/#seo-and-social-tags-seo","text":"Since the web-app with metabake is statically generated it is great a SEO. Of course coming up with keywords for your landing pages is hard work and outside the scope of this documentation. And you should register any website or blog with 'Google Webmasters search console': since it allows to instantly check that the page SEO is working. Otherwise you are waiting for weeks to just change some code. Make sure you submit the page you are working on to 'Google Webmasters search console' so you can see how the SEO sees it.","title":"SEO and social tags SEO"},{"location":"SEO/#social-seo","text":"And we help with social SEO, eg: If your dat.yaml is like this: title: MetaBake trade; versus other Low-Code tools image: slide-3.jpg content_text: MetaBake trade; is the open source extensible low-code productivity tool for programmers. keywords: low-code, gulp, grunt, CMS, static gen Then you can do social SEO like this - for example in your head.pug that you include in your pages or layouts: title #{title} meta(name='description', content=content_text) meta(name= google-site-verification , content= xyz ) // Twitter Card data meta(name='twitter:card', content='summary_large_image') meta(name='twitter:title', content=title) meta(name='twitter:description', content=content_text) meta(name='twitter:image', content=image) // Open Graph data meta(property='og:title', content=title) meta(property='og:type', content='article') meta(property='og:image', content=image) meta(property='og:description', content=comment)","title":"Social SEO"},{"location":"crud/","text":"Dynamic data/CRUD/'ViewModel' This relates to dynamic data, not static content (static eg: CMS or eCommerce). To extract an example CRUD web-app in the current folder: mbake -u It has a README.md in root of the website that you can glance. For CRUD, we'll take it in steps. It should be easier, but there is some wider knowledge needed. CRUD Step 1 - Table You should know HTML Forms, default UI style is http://github.com/kumailht/gridforms For table we use http://github.com/olifolkerd/tabulator in the ./CRUD/screen/tabulator you can see the example. You should at least glance it. CRUD Step 2 - ViewModel! and UI-first The screen in ./CRUD/screen/tabulator, lets work with just that one screen for a bit. It has a 'databinding' (TabulatorBind.js) and it reads from a ViewModel(VM), in ./CRUD/assets/TabulatorViewModel.ts! So lets zoom out for a second for the Table example: - There is a view: index.pug (that extends a layout). The view contains the table Tabulator.js from above linked github (and tabulator.js is loaded via depp.js) - The view has a databinding to get/set 'fields' in the view. - The databinding uses a VM: ./CRUD/assets/TabulatorViewModel.ts Briefly, a VM is a VM when it's 'public' methods 'map' to the view. And it is the VM that calls remote API services. VM - The main part So what is VM? It is the keystone of the modern M-VM-V application architecture. A VM's public methods map to a view. That is 99% of a VM. It is a class where it's public methods map to the view(in our case Pug): - If you have 2 tables in your view, then VM needs to have 2 arrays - If you have 2 forms in your view, then VM needs to have 2 objects, since objects have name-value pairs. - If you have 2 charts in your view, then VM needs to have 2 objects in a way that makes it easy to bind to the chart. In the same way a server side 'ORM Model' may 'map' to the a table|document fields, the VM maps to the view. The VM does not represent server side ORM or stores in any way - it ignores it! The VM maps to the view, and makes it easy to map/bind to the view. So a VM is a complex VM that fully maps to the View! If you change the View, you must change the VM and if you change the VM, you must change the View. One of the goals of VM is to make it easy to 'bind' to the view, so VM must represent the View as a 'model' of it. In object-oriented(OO) development you should avoid deep inheritance for the VM, just a plain class may work best. But in .ts we do use interface to demonstrate that the class maps to the Pug view. When .ts is compiled to js those interfaces are dropped. Once you understand VM, proceed to the rest of this document. Later you'll realize that VM is main part of CRUD/Dynamic apps. Important: The VM should have 'fake' data during iterative development. This enables rapid prototyping. During the early iterations you are just making sure the view is what the customer want's - without any regard how the data will be retrieved or stored! Because the challenge is to understand the requirements and what value customer derives from that screen/page. Implementing (REST or similar) services later is not the challenge for experienced developers - so focus on UI and the requirements and rapid iterations. VM Part 2 - Validation Now lets look our second screen in CRUD example: in ./CRUD/screen/validation That binds to ./CRUD/assets/ValidationViewModel. We perform the validation in the VM, returning 'OK' if OK and an error message if not OK. The View's binding method does the pop up screen. CRUD Step 3 - CRUD Once the iterations show that UI is what customers want, you can start implementing the back end, and CRUD methods. Take a look at ./CRUD/screen/tabulator_form and it's VM. It uses FireStore back end, and when the user clicks on a row in the table we see the Form details. For back end we had to use something, so we used Google FireStore, so you'll have to review the docs on their site for any back end code. The service calls are under ./CRUD/assets/models/service as a separate class that calls the remote back end APIs. We add CRUD and similar methods to VM via OO compositions; buy adding classes/systems that perform those services for the VM class. What we do here in VM is remap how the services return the data into how the View needs the data. Maybe a service is 2 calls to 3 tables/documents - but it all goes into a single form. The VM does that re-mapping. For this example we used S-cVM-V application architecture. Where S is services and cVM is the complex VM that maps to the entire page/screen. CRUD Step 4 - Testing Todo qunit You can do an integration test by going over a user story and loading ViewModels as needed to complete the test. Doing a very detailed test tends to reduce development velocity, but a light smoke test can make it easier to find out if the bug is in the view side or on the VM side. Auth There is also an example of doing user auth in CRUD example app. We just followed the FireStore docs. Other If you are not a fan of Google FireStore, you may like the SaaS DreamFactory hosted by DreamFactory. Review A VM models the View by mapping to the view to make the biding easier - and VM calls back end services.","title":"Dynamic data/CRUD/'ViewModel' example"},{"location":"crud/#dynamic-datacrudviewmodel","text":"This relates to dynamic data, not static content (static eg: CMS or eCommerce). To extract an example CRUD web-app in the current folder: mbake -u It has a README.md in root of the website that you can glance. For CRUD, we'll take it in steps. It should be easier, but there is some wider knowledge needed.","title":"Dynamic data/CRUD/'ViewModel'"},{"location":"crud/#crud-step-1-table","text":"You should know HTML Forms, default UI style is http://github.com/kumailht/gridforms For table we use http://github.com/olifolkerd/tabulator in the ./CRUD/screen/tabulator you can see the example. You should at least glance it.","title":"CRUD Step 1 - Table"},{"location":"crud/#crud-step-2-viewmodel-and-ui-first","text":"The screen in ./CRUD/screen/tabulator, lets work with just that one screen for a bit. It has a 'databinding' (TabulatorBind.js) and it reads from a ViewModel(VM), in ./CRUD/assets/TabulatorViewModel.ts! So lets zoom out for a second for the Table example: - There is a view: index.pug (that extends a layout). The view contains the table Tabulator.js from above linked github (and tabulator.js is loaded via depp.js) - The view has a databinding to get/set 'fields' in the view. - The databinding uses a VM: ./CRUD/assets/TabulatorViewModel.ts Briefly, a VM is a VM when it's 'public' methods 'map' to the view. And it is the VM that calls remote API services.","title":"CRUD Step 2 - ViewModel! and UI-first"},{"location":"crud/#vm-the-main-part","text":"So what is VM? It is the keystone of the modern M-VM-V application architecture. A VM's public methods map to a view. That is 99% of a VM. It is a class where it's public methods map to the view(in our case Pug): - If you have 2 tables in your view, then VM needs to have 2 arrays - If you have 2 forms in your view, then VM needs to have 2 objects, since objects have name-value pairs. - If you have 2 charts in your view, then VM needs to have 2 objects in a way that makes it easy to bind to the chart. In the same way a server side 'ORM Model' may 'map' to the a table|document fields, the VM maps to the view. The VM does not represent server side ORM or stores in any way - it ignores it! The VM maps to the view, and makes it easy to map/bind to the view. So a VM is a complex VM that fully maps to the View! If you change the View, you must change the VM and if you change the VM, you must change the View. One of the goals of VM is to make it easy to 'bind' to the view, so VM must represent the View as a 'model' of it. In object-oriented(OO) development you should avoid deep inheritance for the VM, just a plain class may work best. But in .ts we do use interface to demonstrate that the class maps to the Pug view. When .ts is compiled to js those interfaces are dropped. Once you understand VM, proceed to the rest of this document. Later you'll realize that VM is main part of CRUD/Dynamic apps.","title":"VM - The main part"},{"location":"crud/#important-the-vm-should-have-fake-data-during-iterative-development","text":"This enables rapid prototyping. During the early iterations you are just making sure the view is what the customer want's - without any regard how the data will be retrieved or stored! Because the challenge is to understand the requirements and what value customer derives from that screen/page. Implementing (REST or similar) services later is not the challenge for experienced developers - so focus on UI and the requirements and rapid iterations.","title":"Important: The VM should have 'fake' data during iterative development."},{"location":"crud/#vm-part-2-validation","text":"Now lets look our second screen in CRUD example: in ./CRUD/screen/validation That binds to ./CRUD/assets/ValidationViewModel. We perform the validation in the VM, returning 'OK' if OK and an error message if not OK. The View's binding method does the pop up screen.","title":"VM Part 2 - Validation"},{"location":"crud/#crud-step-3-crud","text":"Once the iterations show that UI is what customers want, you can start implementing the back end, and CRUD methods. Take a look at ./CRUD/screen/tabulator_form and it's VM. It uses FireStore back end, and when the user clicks on a row in the table we see the Form details. For back end we had to use something, so we used Google FireStore, so you'll have to review the docs on their site for any back end code. The service calls are under ./CRUD/assets/models/service as a separate class that calls the remote back end APIs. We add CRUD and similar methods to VM via OO compositions; buy adding classes/systems that perform those services for the VM class. What we do here in VM is remap how the services return the data into how the View needs the data. Maybe a service is 2 calls to 3 tables/documents - but it all goes into a single form. The VM does that re-mapping. For this example we used S-cVM-V application architecture. Where S is services and cVM is the complex VM that maps to the entire page/screen.","title":"CRUD Step 3 - CRUD"},{"location":"crud/#crud-step-4-testing","text":"Todo qunit You can do an integration test by going over a user story and loading ViewModels as needed to complete the test. Doing a very detailed test tends to reduce development velocity, but a light smoke test can make it easier to find out if the bug is in the view side or on the VM side.","title":"CRUD Step 4 - Testing"},{"location":"crud/#auth","text":"There is also an example of doing user auth in CRUD example app. We just followed the FireStore docs.","title":"Auth"},{"location":"crud/#other","text":"If you are not a fan of Google FireStore, you may like the SaaS DreamFactory hosted by DreamFactory.","title":"Other"},{"location":"crud/#review","text":"A VM models the View by mapping to the view to make the biding easier - and VM calls back end services.","title":"Review"},{"location":"css/","text":"SASS CSS can be hard to work with so people use Sass/Scss. Create a ex.sass file: $font-stack: Helvetica, sans-serif; $primary-color: #333; body { font: 100% $font-stack; color: $primary-color; } Create a files assets.yaml css: - ex.sass and run mbake -s . It will create a css file with auto-prefixes. More on Sass In general you should leverage a CSS framework, there are many to chose from. We default to http://github.com/picturepan2/spectre , it looks nice, is small, has full features and can be modified for AMP. For font, we default to Open Sans, but like a CSS framework, you can use any. Also, as mentioned before MetaBake Markdown supports css classes.","title":"SCSS|CSS"},{"location":"css/#sass","text":"CSS can be hard to work with so people use Sass/Scss. Create a ex.sass file: $font-stack: Helvetica, sans-serif; $primary-color: #333; body { font: 100% $font-stack; color: $primary-color; } Create a files assets.yaml css: - ex.sass and run mbake -s . It will create a css file with auto-prefixes.","title":"SASS"},{"location":"css/#more-on-sass","text":"In general you should leverage a CSS framework, there are many to chose from. We default to http://github.com/picturepan2/spectre , it looks nice, is small, has full features and can be modified for AMP. For font, we default to Open Sans, but like a CSS framework, you can use any. Also, as mentioned before MetaBake Markdown supports css classes.","title":"More on Sass"},{"location":"itemize/","text":"Blog/Itemize example Itemize (eg Blog) Lets build a folder called Items and in that folder create create a blank file dat_i.yaml, with nothing there. In the folder called Items create folder Page1 and folder Page2. In each page folder create index.pug and dat.yaml. So you have Page1 and Page2 folder under items In each Page's dat.yaml add title: Page name And add a few more key/value words in each dat.yaml, but make each pages values a bit different. And now, in the folder Items run mbake -i . It will create items.json. This allows you to fetch that json; and search for content, blog, items, etc. mbake -b will emit an example blog with above. The example blog will also show you how the items.json is read to display a nice searchable and paginated list of items. No magic.","title":"Blog/Itemize example"},{"location":"itemize/#blogitemize-example","text":"","title":"Blog/Itemize example"},{"location":"itemize/#itemize-eg-blog","text":"Lets build a folder called Items and in that folder create create a blank file dat_i.yaml, with nothing there. In the folder called Items create folder Page1 and folder Page2. In each page folder create index.pug and dat.yaml. So you have Page1 and Page2 folder under items In each Page's dat.yaml add title: Page name And add a few more key/value words in each dat.yaml, but make each pages values a bit different. And now, in the folder Items run mbake -i . It will create items.json. This allows you to fetch that json; and search for content, blog, items, etc.","title":"Itemize (eg Blog)"},{"location":"itemize/#mbake-b-will-emit-an-example-blog-with-above","text":"The example blog will also show you how the items.json is read to display a nice searchable and paginated list of items. No magic.","title":"mbake -b will emit an example blog with above."},{"location":"more/","text":"mbake review, extras and next steps 'All my friends KNOW the low-coder' mbake is the open source modern tool for developers that makes you most productive: it makes Pug, SCSS and Typescript. It comes with example apps that include WebSite showing how to load.js, CRUD showing how to do dynamic apps. You can use any application architecture you like, but Also it you you can itemize (-i dat.yaml files) to make a nice SEO friendly blog. Extras and next steps Now that you know mbake foundation, here are some choices for next things to learn in the advanced docs, pick and chose: baseCMS: an admin panel that you can host to can use as is; or as a base to build commercial grade CMS or eCommerce site, including browser plugin. MetaCake: plugin components, makes it easy for designers to write real web-apps. Developed with RIOTjs, easier than Reactjs (commercial license optional) AMP SPA router: with page transition effects and state machine (needed for cross-platform development) Cross platform development with real single code base development: single code base for Web, AMP, Electron and PhoneGap/Crodova VS code from the Cloud: multiple developers using a browser against same VS Code host in the cloud Other examples include: - Using markdown CSS effect: allows non-programmers to write interactive stories - Slide show with markdown - Dashboard example - Ads example More: - Online support and (optionally commercial) training - PWA - Federated CMS (commercial) - Consulting: audit software development productivity best practices - Commercial development by sponsor: www.MetaBake.net - 10X cheaper and faster","title":"mbake review, extras and next steps"},{"location":"more/#mbake-review-extras-and-next-steps","text":"","title":"mbake review, extras and next steps"},{"location":"more/#all-my-friends-know-the-low-coder","text":"mbake is the open source modern tool for developers that makes you most productive: it makes Pug, SCSS and Typescript. It comes with example apps that include WebSite showing how to load.js, CRUD showing how to do dynamic apps. You can use any application architecture you like, but Also it you you can itemize (-i dat.yaml files) to make a nice SEO friendly blog.","title":"'All my friends KNOW the low-coder'"},{"location":"more/#extras-and-next-steps","text":"Now that you know mbake foundation, here are some choices for next things to learn in the advanced docs, pick and chose: baseCMS: an admin panel that you can host to can use as is; or as a base to build commercial grade CMS or eCommerce site, including browser plugin. MetaCake: plugin components, makes it easy for designers to write real web-apps. Developed with RIOTjs, easier than Reactjs (commercial license optional) AMP SPA router: with page transition effects and state machine (needed for cross-platform development) Cross platform development with real single code base development: single code base for Web, AMP, Electron and PhoneGap/Crodova VS code from the Cloud: multiple developers using a browser against same VS Code host in the cloud Other examples include: - Using markdown CSS effect: allows non-programmers to write interactive stories - Slide show with markdown - Dashboard example - Ads example More: - Online support and (optionally commercial) training - PWA - Federated CMS (commercial) - Consulting: audit software development productivity best practices - Commercial development by sponsor: www.MetaBake.net - 10X cheaper and faster","title":"Extras and next steps"},{"location":"pug/","text":"Pug Markup We use Pug instead of html: body h1 Pug - node template engine //- a comment in Puf #container.col p You are amazing instead of: body h1 Jade - node template engine /h1 div class= col id= container p You are amazing /p /div /body So if you know html, you know Pug! If you need more of an intro to Pug Pug (aka Jade) on Youtube In addition you can include html parts as needed: include includes/head Also you extend a layout, you can see that in the example apps. And there are online converters where you type in html and it gives you pug equivalent. (eg: http://pug.MetaBake.org) And that is all there is about Pug. To make/build mbake . where . is the current directory to build, or can be a path. If there is no index.pug and dat.yaml it will not build. dat.yaml In order to 'make' index.html from an index.pug, it needs a dat.yaml in the same folder, eg: key1: World title: My page about puppies #special words: basedir: ../../ pretty: false You can use any name/vale, and then use in Pug like: p Hello #{key1} for example with page Title that may need to be a h1 as well. This is often used for SEO tags, for example Twitter and Linkedin in tags often have same keyword text. There are some special words like: pretty. If pretty: true, it will make a nice looking htlm, it won't be compressed. basedir keywords sets the base directory to look for includes, so in pug you can say / / is the base dir. If you move the page folder, you can then just change your basedir in dat.yaml. Markdown include:metaMD comment.md And example Markdown file with CSS style # header {.style-me} I think this is good. This lets you include Markdown in Pug. Markdown is great for people that are not technical to generate content. ( eg: http://Markdown-it.github.io, but with Markdown-it-attrs ) Folder Structure In examples you can see typically application page structure: /pages/page1 /pages/page2 /pages/page3 /layouts /includes /assets Each page should have all its own assets in its folder. This avoids 'digital rot' where a page stops working as its assets are misplaced. The other support folders like /layouts, /includes, and /assets are used only if something is needed in more than one page. In a 'header.pug' or similar file you can include 'a href' to link to other pages. There are other ways to link to pages in advanced sections. Watcher This will start a webserver and auto-refresh browser, and watch for file changes to auto build: mbakeX -w . Instead of . you can specify any path. Also, the fact that we are generating this static content allows us to have the entire webapp served by a CDN. (For origin we mostly use Caddy http server) Re: Build Tools Gulp/Grunt You can also transpile Pug with other build tools like Gulp/Grunt (or even prepros.io) using their syntax. mbake CLI is written in .js. This allows us to use the latest features of the needed npm libraries. And allows you to extend our classes to write your custom version of mbake CLI - explained in the advanced sections. At least MetaBake should inspire you to use generators.","title":"HTML/Pug and dat.yaml"},{"location":"pug/#pug-markup","text":"We use Pug instead of html: body h1 Pug - node template engine //- a comment in Puf #container.col p You are amazing instead of: body h1 Jade - node template engine /h1 div class= col id= container p You are amazing /p /div /body So if you know html, you know Pug! If you need more of an intro to Pug Pug (aka Jade) on Youtube In addition you can include html parts as needed: include includes/head Also you extend a layout, you can see that in the example apps. And there are online converters where you type in html and it gives you pug equivalent. (eg: http://pug.MetaBake.org) And that is all there is about Pug.","title":"Pug Markup"},{"location":"pug/#to-makebuild","text":"mbake . where . is the current directory to build, or can be a path. If there is no index.pug and dat.yaml it will not build.","title":"To make/build"},{"location":"pug/#datyaml","text":"In order to 'make' index.html from an index.pug, it needs a dat.yaml in the same folder, eg: key1: World title: My page about puppies #special words: basedir: ../../ pretty: false You can use any name/vale, and then use in Pug like: p Hello #{key1} for example with page Title that may need to be a h1 as well. This is often used for SEO tags, for example Twitter and Linkedin in tags often have same keyword text. There are some special words like: pretty. If pretty: true, it will make a nice looking htlm, it won't be compressed. basedir keywords sets the base directory to look for includes, so in pug you can say / / is the base dir. If you move the page folder, you can then just change your basedir in dat.yaml.","title":"dat.yaml"},{"location":"pug/#markdown","text":"include:metaMD comment.md And example Markdown file with CSS style # header {.style-me} I think this is good. This lets you include Markdown in Pug. Markdown is great for people that are not technical to generate content. ( eg: http://Markdown-it.github.io, but with Markdown-it-attrs )","title":"Markdown"},{"location":"pug/#folder-structure","text":"In examples you can see typically application page structure: /pages/page1 /pages/page2 /pages/page3 /layouts /includes /assets Each page should have all its own assets in its folder. This avoids 'digital rot' where a page stops working as its assets are misplaced. The other support folders like /layouts, /includes, and /assets are used only if something is needed in more than one page.","title":"Folder Structure"},{"location":"pug/#in-a-headerpug-or-similar-file-you-can-include-a-href-to-link-to-other-pages-there-are-other-ways-to-link-to-pages-in-advanced-sections","text":"","title":"In a 'header.pug' or similar file you can include 'a href' to link to other pages. There are other ways to link to pages in advanced sections."},{"location":"pug/#watcher","text":"This will start a webserver and auto-refresh browser, and watch for file changes to auto build: mbakeX -w . Instead of . you can specify any path. Also, the fact that we are generating this static content allows us to have the entire webapp served by a CDN. (For origin we mostly use Caddy http server)","title":"Watcher"},{"location":"pug/#re-build-tools-gulpgrunt","text":"You can also transpile Pug with other build tools like Gulp/Grunt (or even prepros.io) using their syntax. mbake CLI is written in .js. This allows us to use the latest features of the needed npm libraries. And allows you to extend our classes to write your custom version of mbake CLI - explained in the advanced sections. At least MetaBake should inspire you to use generators.","title":"Re: Build Tools Gulp/Grunt"},{"location":"res/","text":"Awesome list of low-code and MetaBake resources: http://github.com/metabake/MetaBake-Docs/tree/master/awesomeReference","title":"Resources"},{"location":"res/#awesome-list-of-low-code-and-metabake-resources","text":"http://github.com/metabake/MetaBake-Docs/tree/master/awesomeReference","title":"Awesome list of low-code and MetaBake&trade; resources:"},{"location":"ts/","text":"TypeScript TypeScript is supper-set of JavaScript. Write a ts file, like foo.ts: foo(i:number) { console.log('oh hi') } and run mbake -t . It will create a .js and min.js files. It will output ES5 to support IE11, so feel free to use class { } syntax. If there is no .ts, than it will simply slightly mimifify js files into min.js (but no ES5 conversion). (of course you have to load any polyfills like promises, fetch or what you need) And normally you run that command at the root of your web-app; but don't use it for server side nodejs. Services TypeScript is often uses to call Services|APIs via browser's fetch() (used to be Ajax). Modern services are now written in Google FireStore, DreamFactory(hosted) and to lesser degree AWS Amplify. These modern type of services help maximite developer productivity. Services are used to develope C.R.U.D. (CRUD: Create, Read, Update, Delete)/ dynamic web-apps. Google and AWS also offer nice user authentication functionality. Even if you won't use Google FireStore: you should learn to use it, just to expose yourself to the modern services architecture! The documentation on their website is quite good, and makes it easy to develop CURD services. When you call the services client side, you can write a .ts class that has the CRUD calls - returning promises (or leveraging browser's Custom Events). This is the class that your Pug(html really) will leverage for dynamic apps. There are much better ways, but just to remove they mystery, here is a (bad) example pseudo code: .script var serv1 = new MyServices1() // this class should have your working FireStore service calls or similar code. var pro1 = serv1.getSome1() pro1.then(function(ret) { $('#someId1').val(ret.field1) }) // note that I'm not a fan of await or arrow syntax There is aldo realistic example CRUD web-app example if you continue reading to the end here: including table, forms, validation, authentication, and 'master/detail' (click on a row to zoom) functionality. The CRUD example also shows how to use the modern ViewModel application architecture.","title":"TypeScript|.js and Services"},{"location":"ts/#typescript","text":"TypeScript is supper-set of JavaScript. Write a ts file, like foo.ts: foo(i:number) { console.log('oh hi') } and run mbake -t . It will create a .js and min.js files. It will output ES5 to support IE11, so feel free to use class { } syntax. If there is no .ts, than it will simply slightly mimifify js files into min.js (but no ES5 conversion). (of course you have to load any polyfills like promises, fetch or what you need) And normally you run that command at the root of your web-app; but don't use it for server side nodejs.","title":"TypeScript"},{"location":"ts/#services","text":"TypeScript is often uses to call Services|APIs via browser's fetch() (used to be Ajax). Modern services are now written in Google FireStore, DreamFactory(hosted) and to lesser degree AWS Amplify. These modern type of services help maximite developer productivity. Services are used to develope C.R.U.D. (CRUD: Create, Read, Update, Delete)/ dynamic web-apps. Google and AWS also offer nice user authentication functionality.","title":"Services"},{"location":"ts/#even-if-you-wont-use-google-firestore-you-should-learn-to-use-it-just-to-expose-yourself-to-the-modern-services-architecture-the-documentation-on-their-website-is-quite-good-and-makes-it-easy-to-develop-curd-services","text":"When you call the services client side, you can write a .ts class that has the CRUD calls - returning promises (or leveraging browser's Custom Events). This is the class that your Pug(html really) will leverage for dynamic apps. There are much better ways, but just to remove they mystery, here is a (bad) example pseudo code: .script var serv1 = new MyServices1() // this class should have your working FireStore service calls or similar code. var pro1 = serv1.getSome1() pro1.then(function(ret) { $('#someId1').val(ret.field1) }) // note that I'm not a fan of await or arrow syntax There is aldo realistic example CRUD web-app example if you continue reading to the end here: including table, forms, validation, authentication, and 'master/detail' (click on a row to zoom) functionality. The CRUD example also shows how to use the modern ViewModel application architecture.","title":"Even if you won't use Google FireStore: you should learn to use it, just to expose yourself to the modern services architecture! The documentation on their website is quite good, and makes it easy to develop CURD services."},{"location":"webs/","text":"Examples - Website There are 12 very different examples included in the mbake CLI. One is just a website: mbake -w That will extract an example website in the current folder. ( Obviously you can create any layout with any combination of css and other libraries, but here is how we laid out an example/starter website). It has a README.md in root of the website. depp.min.js Most example web-apps, including the website, need to load external .js libraries. MetaBake example the use the CDN centric .js loader 'depp': http://github.com/muicss/johnnydepp but you can use any 'loader' lib you like. But learn the default depp.js, since all the examples us that one: // define dependencies depp.define({ 'jquery': ['/path/to/jquery.js'], 'plugin1': ['#jquery', '/path/to/plugin1.js', '/path/to/plugin1.css', '/path/to/plugin1.png'], 'plugin2': ['#jquery', '/path/to/plugin2.js', '/path/to/plugin2.css', '/path/to/plugin2.png'] }) // load dependencies depp.require(['plugin1', 'plugin2'], function() { /* plugin1 and plugin2 are ready to be used */ }) You'll find the real loading code in /assets/js/loader.js. Our preferred CDN host for external .js libs is: http://jsdelivr.com You should review the standard layout of folders: - /layouts has the main Pug layouts that each page extends. - /landing/* has the website pages, the index.pug and dat.yaml. To navigate to a webpage is a 'a href' to the /landing/page1 or landing/page2. - /assets/assets.yaml to process the Sass into css There are many navigation libraries on github - a way to create a navbar, and we leverage one in here. In advanced docs we review some nav libs, but not here. And as mentioned at the start: there are 12 example of very different web-apps, you should study a few to see how we chose to layout things so you get your own ideas. (Notice there is also a loader.min.js. mbake -t created the min file, even when .ts is not found it semi minimizes .js. It does not do a full min so that in production we can have reasonable error messages about our code. )","title":"Website w/ loading .js libs example"},{"location":"webs/#examples-website","text":"There are 12 very different examples included in the mbake CLI. One is just a website: mbake -w That will extract an example website in the current folder. ( Obviously you can create any layout with any combination of css and other libraries, but here is how we laid out an example/starter website). It has a README.md in root of the website.","title":"Examples - Website"},{"location":"webs/#deppminjs","text":"Most example web-apps, including the website, need to load external .js libraries. MetaBake example the use the CDN centric .js loader 'depp': http://github.com/muicss/johnnydepp but you can use any 'loader' lib you like. But learn the default depp.js, since all the examples us that one: // define dependencies depp.define({ 'jquery': ['/path/to/jquery.js'], 'plugin1': ['#jquery', '/path/to/plugin1.js', '/path/to/plugin1.css', '/path/to/plugin1.png'], 'plugin2': ['#jquery', '/path/to/plugin2.js', '/path/to/plugin2.css', '/path/to/plugin2.png'] }) // load dependencies depp.require(['plugin1', 'plugin2'], function() { /* plugin1 and plugin2 are ready to be used */ }) You'll find the real loading code in /assets/js/loader.js. Our preferred CDN host for external .js libs is: http://jsdelivr.com You should review the standard layout of folders: - /layouts has the main Pug layouts that each page extends. - /landing/* has the website pages, the index.pug and dat.yaml. To navigate to a webpage is a 'a href' to the /landing/page1 or landing/page2. - /assets/assets.yaml to process the Sass into css There are many navigation libraries on github - a way to create a navbar, and we leverage one in here. In advanced docs we review some nav libs, but not here. And as mentioned at the start: there are 12 example of very different web-apps, you should study a few to see how we chose to layout things so you get your own ideas. (Notice there is also a loader.min.js. mbake -t created the min file, even when .ts is not found it semi minimizes .js. It does not do a full min so that in production we can have reasonable error messages about our code. )","title":"depp.min.js"}]}