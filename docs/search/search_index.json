{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is mbake? mbake is a modern CLI static app generation tool. Apps and sites you generate with mbake are extreme serverless, allow user authentication and work with JSON and database APIs for dynamic databinding. You can use mbake for simple blogs or sites to the most complex web and mobile app projects. If you don't have time, see tl;dr at the bottom of this page. mbake compares to other static generators and grunt/gulp; but it does a lot more with a lot less coding. mbake is part of the MetaBake\u2122 approach but can be used by itself. What is MetaBake? MetaBake\u2122 is a modern development approach that helps you deliver web apps 10X faster with less coding. MetaBake\u2122 has 10 pillars. Find out more about MetaBake: Quick Demo Meetup Video Slide Deck Summary for Managers MetaBake allows for gradual adoption. You can start by adopting just one or a few of its pillars. mbake is a good start. MetaBake and mbake are open source. The source code is available at github.com/MetaBake See Resources for related projects. How to install mbake From a command line such as PowerShell, type: $ yarn global add mbake That's it! If you don't have Yarn installed, first go here . How to create a Hello World app with mbake ## Create index.pug header body p Hello #{key1} ## Create dat.yaml key1: World ## Generate index.html from Pug and Yaml: mbake . or: mbake subfoldername Auto-build/generate: if you are using a MetaBake META build server (see META doc), you don't even have to do the 'mbake .'. META has a watcher that triggers 'mbake' when you save a file. How to run an mbake app (such as Hello World) mbake apps run on any static web server. This includes low-cost cloud hosting such as Amazon S3. We show how to work with S3 later in this doc. When you develop locally, you could use 'Web Server for Chrome' to run mbake apps. To install it, open your Google Chrome web browser and install the 'Web Server for Chrome' app from here . Launch the app, click the 'Choose Folder' button and select the root folder of your app (e.g. where index.html of your Hello World app is). Also ensure 'Options' has 'Automatically show index.html' checked. Ensure the Web Server is STARTED, then navigate to the proposed URL (e.g. http://127.0.0.1:8887). Even though mbake apps are installed on a static server, they are dynamic because they allow user authentication and work with JSON for dynamic rendering and database APIs for dynamic databinding. How to generate a sample app with mbake ## Run mbake help to see the list of current sample apps mbake ## Generate sample app, e.g. mbake -c ## Navigate to it, e.g. cd crud Other popular mbake commands mbake -t . - Convert Pug/Riot files to useable tag/js, e.g.: data binding. mbake -i . - Convert dat.yaml static files to JSON, for dynamic binding. More about this in B-M-SPA docs. How to see all mbake options $ mbake How to make mbake apps serverless To go extreme serverless, we show how to use mbake with Amazon Web Services (AWS) S3 HTTP hosting Mounting software so you can mount AWS S3 as a drive Google Firebase/Firestore Go extreme serverless following the steps (Tutorials): Setup S3 as your HTTP server and mount it Mount S3 to linux box via goofys using CodeAnywhere editor Learn Pug and static binding; view via S3 HTTP server Spectre SCSS Theme Framework and SCSS dynamic databinding Generate a serverless CRUD webapp Simple CRUD example app and ViewModel+Bind Design Blog When done, you should see this . Serverless/Cloud V2, Mount and Pug are some of the pillars of MetaBake. tl;dr $ yarn global add mbake $ mbake $ mbake -c $ cd crud $ mbake . NEXT: Go to Setup S3 as your HTTP server and mount it .","title":"Home"},{"location":"#what-is-mbake","text":"mbake is a modern CLI static app generation tool. Apps and sites you generate with mbake are extreme serverless, allow user authentication and work with JSON and database APIs for dynamic databinding. You can use mbake for simple blogs or sites to the most complex web and mobile app projects. If you don't have time, see tl;dr at the bottom of this page. mbake compares to other static generators and grunt/gulp; but it does a lot more with a lot less coding. mbake is part of the MetaBake\u2122 approach but can be used by itself.","title":"What is mbake?"},{"location":"#what-is-metabake","text":"MetaBake\u2122 is a modern development approach that helps you deliver web apps 10X faster with less coding. MetaBake\u2122 has 10 pillars. Find out more about MetaBake: Quick Demo Meetup Video Slide Deck Summary for Managers MetaBake allows for gradual adoption. You can start by adopting just one or a few of its pillars. mbake is a good start. MetaBake and mbake are open source. The source code is available at github.com/MetaBake See Resources for related projects.","title":"What is MetaBake?"},{"location":"#how-to-install-mbake","text":"From a command line such as PowerShell, type: $ yarn global add mbake That's it! If you don't have Yarn installed, first go here .","title":"How to install mbake"},{"location":"#how-to-create-a-hello-world-app-with-mbake","text":"## Create index.pug header body p Hello #{key1} ## Create dat.yaml key1: World ## Generate index.html from Pug and Yaml: mbake . or: mbake subfoldername Auto-build/generate: if you are using a MetaBake META build server (see META doc), you don't even have to do the 'mbake .'. META has a watcher that triggers 'mbake' when you save a file.","title":"How to create a Hello World app with mbake"},{"location":"#how-to-run-an-mbake-app-such-as-hello-world","text":"mbake apps run on any static web server. This includes low-cost cloud hosting such as Amazon S3. We show how to work with S3 later in this doc. When you develop locally, you could use 'Web Server for Chrome' to run mbake apps. To install it, open your Google Chrome web browser and install the 'Web Server for Chrome' app from here . Launch the app, click the 'Choose Folder' button and select the root folder of your app (e.g. where index.html of your Hello World app is). Also ensure 'Options' has 'Automatically show index.html' checked. Ensure the Web Server is STARTED, then navigate to the proposed URL (e.g. http://127.0.0.1:8887). Even though mbake apps are installed on a static server, they are dynamic because they allow user authentication and work with JSON for dynamic rendering and database APIs for dynamic databinding.","title":"How to run an mbake app (such as Hello World)"},{"location":"#how-to-generate-a-sample-app-with-mbake","text":"## Run mbake help to see the list of current sample apps mbake ## Generate sample app, e.g. mbake -c ## Navigate to it, e.g. cd crud","title":"How to generate a sample app with mbake"},{"location":"#other-popular-mbake-commands","text":"mbake -t . - Convert Pug/Riot files to useable tag/js, e.g.: data binding. mbake -i . - Convert dat.yaml static files to JSON, for dynamic binding. More about this in B-M-SPA docs.","title":"Other popular mbake commands"},{"location":"#how-to-see-all-mbake-options","text":"$ mbake","title":"How to see all mbake options"},{"location":"#how-to-make-mbake-apps-serverless","text":"To go extreme serverless, we show how to use mbake with Amazon Web Services (AWS) S3 HTTP hosting Mounting software so you can mount AWS S3 as a drive Google Firebase/Firestore","title":"How to make mbake apps serverless"},{"location":"#go-extreme-serverless-following-the-steps-tutorials","text":"Setup S3 as your HTTP server and mount it Mount S3 to linux box via goofys using CodeAnywhere editor Learn Pug and static binding; view via S3 HTTP server Spectre SCSS Theme Framework and SCSS dynamic databinding Generate a serverless CRUD webapp Simple CRUD example app and ViewModel+Bind Design Blog When done, you should see this . Serverless/Cloud V2, Mount and Pug are some of the pillars of MetaBake.","title":"Go extreme serverless following the steps (Tutorials):"},{"location":"#tldr","text":"$ yarn global add mbake $ mbake $ mbake -c $ cd crud $ mbake . NEXT: Go to Setup S3 as your HTTP server and mount it .","title":"tl;dr"},{"location":"about/","text":"Click for 'THE' mbake Docs Low-code = 10X faster web app development. With MetaBake's modern development approach, it is not about replacing your tech stack with another tech stack -- it is about eliminating it! About MetaBake mBake.org is a development productivity suite. It should allow you to deliver 10 times faster then legacy development stacks/methodologies. We have found that - with mBake.org; - the work of 6 developers over 6 months can be done by 3 developers in 3 weeks. We expect you to achieve the same productivity gains. How does open source MetaBake deliver 10X faster and cheaper web app development? Not enough organizations are fully leveraging the new Serverless. With Serverless services like Firestore and S3 you get rid of ALL server-side and middleware development and operations. This is where up to 2/3 of your time and cost used to go. Gone! On the client side (browser apps and mobile apps) MetaBake does something similar: it eliminates much of the tech stack and reduces the amount of coding and complexity. How? In school textbooks you learned about 1st generation languages, 2nd generation languages and our current 3rd generation languages, such as JavaScript, PHP and Ruby. With each new generation we achieved huge productivity improvements. We consider 'Pug'--also used by Node/Express--a 4th generation language that helps gain an equally big jump in productivity. With MetaBake we show you how to build complete applications in Pug. With this Low-code approach we demonstrate much faster and cheaper web app and mobile app development. The MetaBake approach has 10 pillars that are the foundation for achieving mind-blowing development productivity gains. I'll just mention one more pillar here: automatic programming. You've probably heard of 'static site generators' like Hugo or Jekyll that people use to generate their web site or a blog. Automatic programming means using a similar generator to write your web app! This can get you to yet another level of productivity. To learn more about the MetaBake approach, including all 10 pillars and full examples, go to mBake.org. Or, to dive in right away, use the 'mbake CLI' from github.com/MetaBake as the first step into 10X faster web app development. mBake.org productivity is based on three modules: mbake, a static site generation tool that runs locally B-M-SPA, curated technologies and techniques that help you build dynamic apps and mobile apps faster Meta, a bespoke cloud-based build and admin app infrastructure that helps deliver functionality to your clients more quickly We benchmark against LAMP , RAILS , MEAN and such For example, LAMP is the technology WordPress was built on. Every 10 years or so technology gets 10 times better, which forces everyone to upgrade. Assembly was 10 times better than machine language. C/.js is 10 times better than Assembly. We believe that we found the answer on how to have a more productive team. So far, somehow, server-side rendered LAMP has dominated web deployments, with WordPress having some 30% of the World Wide Web. It is time to start displacing that. You can reinvest the time saved by using MetaBake into a more interactive user experience (UX). Better UX is proven to lead into higher user engagement and better user retention. About mbake mbake leverages the clarity, simplicity and productivity gained by using the declarative markup language Pug . We think of Pug as 4GL. mbake currently compiles Pug, Markdown and Yaml to generate HTML and JSON. Using the power of JavaScript, more transformers can be added. mbake runs as a small node process, either on your machine or in the cloud. mbake generates static sites, but it also supports making those sites dynamic with API calls and data feeds such as from JSON. mbake helps is another example of a http://staticgen.com webapp. mbake includes sample starters apps for CRUD. After you are comfortable with mbake, check out B-M-SPA and Meta. Prerequisites: you should know HTML and CSS. If you need to catch up, we recommend 'Design and Build Websites' by Jon Duckett. You will also learn Pug, to get started on Pug, watch Pug on Youtube Best way to get started with mbake is to read the Docs, linked at he top of the page.","title":"About"},{"location":"about/#low-code-10x-faster-web-app-development","text":"","title":"Low-code = 10X faster web app development."},{"location":"about/#with-metabakes-modern-development-approach-it-is-not-about-replacing-your-tech-stack-with-another-tech-stack-it-is-about-eliminating-it","text":"","title":"With MetaBake's modern development approach, it is not about replacing your tech stack with another tech stack -- it is about eliminating it!"},{"location":"about/#about-metabake","text":"mBake.org is a development productivity suite. It should allow you to deliver 10 times faster then legacy development stacks/methodologies. We have found that - with mBake.org; - the work of 6 developers over 6 months can be done by 3 developers in 3 weeks. We expect you to achieve the same productivity gains. How does open source MetaBake deliver 10X faster and cheaper web app development? Not enough organizations are fully leveraging the new Serverless. With Serverless services like Firestore and S3 you get rid of ALL server-side and middleware development and operations. This is where up to 2/3 of your time and cost used to go. Gone! On the client side (browser apps and mobile apps) MetaBake does something similar: it eliminates much of the tech stack and reduces the amount of coding and complexity. How? In school textbooks you learned about 1st generation languages, 2nd generation languages and our current 3rd generation languages, such as JavaScript, PHP and Ruby. With each new generation we achieved huge productivity improvements. We consider 'Pug'--also used by Node/Express--a 4th generation language that helps gain an equally big jump in productivity. With MetaBake we show you how to build complete applications in Pug. With this Low-code approach we demonstrate much faster and cheaper web app and mobile app development. The MetaBake approach has 10 pillars that are the foundation for achieving mind-blowing development productivity gains. I'll just mention one more pillar here: automatic programming. You've probably heard of 'static site generators' like Hugo or Jekyll that people use to generate their web site or a blog. Automatic programming means using a similar generator to write your web app! This can get you to yet another level of productivity. To learn more about the MetaBake approach, including all 10 pillars and full examples, go to mBake.org. Or, to dive in right away, use the 'mbake CLI' from github.com/MetaBake as the first step into 10X faster web app development.","title":"About MetaBake"},{"location":"about/#mbakeorg-productivity-is-based-on-three-modules","text":"mbake, a static site generation tool that runs locally B-M-SPA, curated technologies and techniques that help you build dynamic apps and mobile apps faster Meta, a bespoke cloud-based build and admin app infrastructure that helps deliver functionality to your clients more quickly We benchmark against LAMP , RAILS , MEAN and such For example, LAMP is the technology WordPress was built on. Every 10 years or so technology gets 10 times better, which forces everyone to upgrade. Assembly was 10 times better than machine language. C/.js is 10 times better than Assembly. We believe that we found the answer on how to have a more productive team. So far, somehow, server-side rendered LAMP has dominated web deployments, with WordPress having some 30% of the World Wide Web. It is time to start displacing that. You can reinvest the time saved by using MetaBake into a more interactive user experience (UX). Better UX is proven to lead into higher user engagement and better user retention.","title":"mBake.org productivity is based on three modules:"},{"location":"about/#about-mbake","text":"mbake leverages the clarity, simplicity and productivity gained by using the declarative markup language Pug . We think of Pug as 4GL. mbake currently compiles Pug, Markdown and Yaml to generate HTML and JSON. Using the power of JavaScript, more transformers can be added. mbake runs as a small node process, either on your machine or in the cloud. mbake generates static sites, but it also supports making those sites dynamic with API calls and data feeds such as from JSON. mbake helps is another example of a http://staticgen.com webapp. mbake includes sample starters apps for CRUD. After you are comfortable with mbake, check out B-M-SPA and Meta. Prerequisites: you should know HTML and CSS. If you need to catch up, we recommend 'Design and Build Websites' by Jon Duckett. You will also learn Pug, to get started on Pug, watch Pug on Youtube Best way to get started with mbake is to read the Docs, linked at he top of the page.","title":"About mbake"},{"location":"blog/","text":"Blog website With the command you can download a blog website example: $ mbake -b -b is blog. It also works for any items, not just articles. In blog, copy folder /blog/post-1 to /blog/blog, rename it to post-1n . Edit some of the content, like the .md file so it's different. Then in /blog run $ mbake -i . That creates a new items.json file. Now view the home page in browser: the new item shows up! The home page does a ajax fetch of the json and shows it. Via a pagination library. Check out the tag in /blog/blog/tags that is the items loop. You should know now how to add any items and show the list of items. When someone adds a new item (via a new folder) it shows up after $ mbake -i . Notice how everything in /blog/blog/post-*/dat.yaml ends up in /blog items.json . That is used in the list. So dat.yaml can show on page, as you learnt from previous tutorials. And can show in list - as above described how to make items.json. That list can then be used by a tag 'iterator'.","title":"Blog"},{"location":"blog/#blog-website","text":"With the command you can download a blog website example: $ mbake -b -b is blog. It also works for any items, not just articles. In blog, copy folder /blog/post-1 to /blog/blog, rename it to post-1n . Edit some of the content, like the .md file so it's different. Then in /blog run $ mbake -i . That creates a new items.json file. Now view the home page in browser: the new item shows up! The home page does a ajax fetch of the json and shows it. Via a pagination library. Check out the tag in /blog/blog/tags that is the items loop. You should know now how to add any items and show the list of items. When someone adds a new item (via a new folder) it shows up after $ mbake -i . Notice how everything in /blog/blog/post-*/dat.yaml ends up in /blog items.json . That is used in the list. So dat.yaml can show on page, as you learnt from previous tutorials. And can show in list - as above described how to make items.json. That list can then be used by a tag 'iterator'.","title":"Blog website"},{"location":"ca/","text":"Mount S3 to linux box via goofys using CodeAnywhere editor Setup cloud dev. Setup up a Linux box in the cloud, e.g. Digital Ocean . Change the root password for DO linux box. Connect by ssh in terminal. It will ask to enter existing password and then new password: $ ssh root@[IP-Address] Setup a Web IDE account, e.g. CodeAnywhere online text editor (hereafter CA) In CA, connect to the Linux box. In CA, open SSH to the Linux box. Cloud Mount S3 Setup S3 mounting software. $ cd ~ $ sudo wget http://bit.ly/goofys-latest $ mv goofys-latest goofys $ sudo chmod +x goofys //just in case you need logs $ ln -s /var/log ~ In mbake, you should be comfortable mounting to the local PC. Now we mount in the cloud using CA. //edit your credentials, [other2] part is very optional, if you need 2 mounts. $ mkdir ~/.aws In CA edit ~/.aws/credentials [default] aws_access_key_id = KEY aws_secret_access_key = SECRET [other2] aws_access_key_id = KEY2 aws_secret_access_key = SECRET2 Make a directory in which you'll mount s3 bucket $ mkdir folder_name // check if folder was created $ ls -la Mount your S3 bucket into it, use your BUCKET-NAME and folder_name ~/goofys --profile default -o allow_other --use-content-type BUCKET-NAME ~/folder_name // check to see your S3 webapp files ls -la // if errors, check /var/log/syslog for direction Install node, yarn and mbake Via git, pull the latest version of some project from the git repository. Change some file, pug or .ts or readme - mbake . it and git push to the git repository. Now you've learned how to develop and operate in the cloud and you can edit your mounted bucket files from CodeAnywhere ssh. In the next tutorial you will learn about Pug and static data binding. NEXT: Go to Templating/Pug and static binding .","title":"Mount S3 to linux box via goofys and CA"},{"location":"ca/#mount-s3-to-linux-box-via-goofys-using-codeanywhere-editor","text":"","title":"Mount S3 to linux box via goofys using CodeAnywhere editor"},{"location":"ca/#setup-cloud-dev","text":"Setup up a Linux box in the cloud, e.g. Digital Ocean . Change the root password for DO linux box. Connect by ssh in terminal. It will ask to enter existing password and then new password: $ ssh root@[IP-Address] Setup a Web IDE account, e.g. CodeAnywhere online text editor (hereafter CA) In CA, connect to the Linux box. In CA, open SSH to the Linux box.","title":"Setup cloud dev."},{"location":"ca/#cloud-mount-s3","text":"Setup S3 mounting software. $ cd ~ $ sudo wget http://bit.ly/goofys-latest $ mv goofys-latest goofys $ sudo chmod +x goofys //just in case you need logs $ ln -s /var/log ~ In mbake, you should be comfortable mounting to the local PC. Now we mount in the cloud using CA. //edit your credentials, [other2] part is very optional, if you need 2 mounts. $ mkdir ~/.aws In CA edit ~/.aws/credentials [default] aws_access_key_id = KEY aws_secret_access_key = SECRET [other2] aws_access_key_id = KEY2 aws_secret_access_key = SECRET2 Make a directory in which you'll mount s3 bucket $ mkdir folder_name // check if folder was created $ ls -la Mount your S3 bucket into it, use your BUCKET-NAME and folder_name ~/goofys --profile default -o allow_other --use-content-type BUCKET-NAME ~/folder_name // check to see your S3 webapp files ls -la // if errors, check /var/log/syslog for direction Install node, yarn and mbake Via git, pull the latest version of some project from the git repository. Change some file, pug or .ts or readme - mbake . it and git push to the git repository. Now you've learned how to develop and operate in the cloud and you can edit your mounted bucket files from CodeAnywhere ssh. In the next tutorial you will learn about Pug and static data binding. NEXT: Go to Templating/Pug and static binding .","title":"Cloud Mount S3"},{"location":"crud/","text":"Generate a serverless CRUD webapp. CRUD stands for create-read-update-delete. In this tutorial, you will learn how to create your own Firestore database, insert data and add authentication to the app. Alongside, you will learn to render lists using https://dataTables.net/ with advanced grid sorting, searching and paging. Firestore database is part of the Google Firestore offering. Similar to AWS Cognito, Firestore includes pure client-side user authentication. Firestore can be used from the browser via JavaScript; no custom serverside code is needed. This is key to be able to develop faster. Firestore is free for up to 50,000 reads and 20,000 writes per day. See more details here . At the time of writing, Firestore is a beta version, but Gmail also was beta for a very long time, without major issues. Firestore has a clean and mature API that is much improved from a previous version of Firebase. Steps We assume you have completed Setup S3 as your HTTP server and mount it , Templating/Pug and static binding and Spectre SCSS Theme Framework and SCSS . Using the AWS S3 browser, create a bucket in the same region as you used in Setup S3 as your HTTP server and mount it . Name the bucket 'wgehner-crud' (replace 'wgehner' with your name or something else unique). Configure the bucket for static website hosting and apply the access policy analog to the 'website' project ( Step 4 in Tutorial 1). Copy the Endpoint URL. The new bucket should appear as a new project root folder in your mapped drive (e.g. as W:\\wgehner-crud ). Extract the CRUD sample project to your computer with '$ mbake -c' and copy the project files (inside of /crud ) into the project root. In a browser, open the Endpoint URL. You should see the CRUD App served by S3. Navigate to the 'DataTable' menu item. Inspect the fragment /datatable/list.pug . Note the table#list1 tag, an empty table with ID list1 , and the setupTable() function that converts the table into a datatable with headers, data and the default features of sorting, in-memory searching and paging. As a next step, navigate to the 'Live CRUD' menu item, and inspect the fragment /live/table.pug . This time, the function read(onData, onErr) in /assets/js/rw.js is responsible for loading the (live) data from a preconfigured Firestore. More about rw.js below. The onData handler in table.pug populates the datatable. To learn Firebase, you will now remap the Firestore connection to your own Firestore. Create a Google account if you don't already have one. Log into https://console.firebase.google.com . Create a project named test-crud . Under the left menu 'Develop - Database', create a Firestore app in test mode. On the Project Overview, click the </> button near 'Add an app to get started' to open a popup. In your mapped project /layout/tags/preRW-tag.pug , overwrite the values for apiKey, authDomain and projectId with the values shown in the Firestore popup and save. Run '$ mbake -t .' from the tags folder. ( /layout/layout.pug will use the updated script(src='/layout/tags/preRW-tag.min.js') .) In a browser, refresh the Live CRUD page. Inspect /screen/live/form.pug and see how the function setupForm() maps button click events to actions in our helper library /assets/js/rw.js . Back in the browser, enter some data in the form fields and click 'Add data'. Back in the Firestore Console, in 'Develop - Database', you should see the inserted data as first item in 'table_one'. Repeat to insert a second item. This form is styled with gridforms . This example uses js-signals to dispatch a row click event and fill the form with the row data. Look for dtSig.dispatch(row) in /screen/live/table.pug . Next inspect /assets/js/rw.js . Look for the function add(row, resolve, reject) that inserts data on button click. You will see something like this: let newPK = db1.collection(window.tablename).doc() // make PK newPK.set(newRow) // insert The JavaScript API of Firestore is intuitive and easy to use. We will now secure the database. In the Firestore Console, on the Rules tab in 'Develop - Database', replace: allow: read, write; with allow read, write: if request.auth.token.email_verified == true; Publish the change. Only logged in users who have been verified by email can now read from or write to the database. Since you are currently not logged in, 'Add data' on the 'CRUD' screen should now fail. We will now configure and test a sign-in method. In the Firestore Console, in 'Develop - Authentication', click on 'Set up sign-in method'. Enable Email/Password sign-up and save. In the CRUD App, navigate to the multi-purpose 'Auth' screen (/screen/auth/). Enter your email and a password and click the 'Sign Up' button. The new user should appear in the Firestore Authentication list of Users. Check your email and click on the link you received (The email can be customized on the Firestore Authentication Templates tab). Return to the Auth screen (/screen/auth/) and click the 'Sign In' button. If the login succeeded, 'Add data' on the 'Live CRUD' screen should now succeed, and you should see the added data in the Firestore database console. Summary: You learnt how to create your own Firestore database, insert data and add authentication to the app, along with using datatables. Firestore replaces MongoDB, but also ORM, REST, DevOps, Security, Failover, etc. Instead of learning all of these, now you only need to learn how to use Firestore. That should create a huge savings in your development and operations budget. NEXT STEPS: You can try out more Template projects (type $ mbake ). You can also setup a META build server. META has a watcher that triggers 'mbake' when you save a file to a mapped drive. You can become 10X more productive by adopting the Metabase approach. Definitely look at: Awesome list of MetaBake resources https://git.mBake.org . In the next tutorial , we cover a view-model pattern . NEXT: Go to Simple CRUD example app and ViewModel+Bind .","title":"Generate a serverless CRUD webapp"},{"location":"crud/#generate-a-serverless-crud-webapp","text":"CRUD stands for create-read-update-delete. In this tutorial, you will learn how to create your own Firestore database, insert data and add authentication to the app. Alongside, you will learn to render lists using https://dataTables.net/ with advanced grid sorting, searching and paging. Firestore database is part of the Google Firestore offering. Similar to AWS Cognito, Firestore includes pure client-side user authentication. Firestore can be used from the browser via JavaScript; no custom serverside code is needed. This is key to be able to develop faster. Firestore is free for up to 50,000 reads and 20,000 writes per day. See more details here . At the time of writing, Firestore is a beta version, but Gmail also was beta for a very long time, without major issues. Firestore has a clean and mature API that is much improved from a previous version of Firebase.","title":"Generate a serverless CRUD webapp."},{"location":"crud/#steps","text":"We assume you have completed Setup S3 as your HTTP server and mount it , Templating/Pug and static binding and Spectre SCSS Theme Framework and SCSS . Using the AWS S3 browser, create a bucket in the same region as you used in Setup S3 as your HTTP server and mount it . Name the bucket 'wgehner-crud' (replace 'wgehner' with your name or something else unique). Configure the bucket for static website hosting and apply the access policy analog to the 'website' project ( Step 4 in Tutorial 1). Copy the Endpoint URL. The new bucket should appear as a new project root folder in your mapped drive (e.g. as W:\\wgehner-crud ). Extract the CRUD sample project to your computer with '$ mbake -c' and copy the project files (inside of /crud ) into the project root. In a browser, open the Endpoint URL. You should see the CRUD App served by S3. Navigate to the 'DataTable' menu item. Inspect the fragment /datatable/list.pug . Note the table#list1 tag, an empty table with ID list1 , and the setupTable() function that converts the table into a datatable with headers, data and the default features of sorting, in-memory searching and paging. As a next step, navigate to the 'Live CRUD' menu item, and inspect the fragment /live/table.pug . This time, the function read(onData, onErr) in /assets/js/rw.js is responsible for loading the (live) data from a preconfigured Firestore. More about rw.js below. The onData handler in table.pug populates the datatable. To learn Firebase, you will now remap the Firestore connection to your own Firestore. Create a Google account if you don't already have one. Log into https://console.firebase.google.com . Create a project named test-crud . Under the left menu 'Develop - Database', create a Firestore app in test mode. On the Project Overview, click the </> button near 'Add an app to get started' to open a popup. In your mapped project /layout/tags/preRW-tag.pug , overwrite the values for apiKey, authDomain and projectId with the values shown in the Firestore popup and save. Run '$ mbake -t .' from the tags folder. ( /layout/layout.pug will use the updated script(src='/layout/tags/preRW-tag.min.js') .) In a browser, refresh the Live CRUD page. Inspect /screen/live/form.pug and see how the function setupForm() maps button click events to actions in our helper library /assets/js/rw.js . Back in the browser, enter some data in the form fields and click 'Add data'. Back in the Firestore Console, in 'Develop - Database', you should see the inserted data as first item in 'table_one'. Repeat to insert a second item. This form is styled with gridforms . This example uses js-signals to dispatch a row click event and fill the form with the row data. Look for dtSig.dispatch(row) in /screen/live/table.pug . Next inspect /assets/js/rw.js . Look for the function add(row, resolve, reject) that inserts data on button click. You will see something like this: let newPK = db1.collection(window.tablename).doc() // make PK newPK.set(newRow) // insert The JavaScript API of Firestore is intuitive and easy to use. We will now secure the database. In the Firestore Console, on the Rules tab in 'Develop - Database', replace: allow: read, write; with allow read, write: if request.auth.token.email_verified == true; Publish the change. Only logged in users who have been verified by email can now read from or write to the database. Since you are currently not logged in, 'Add data' on the 'CRUD' screen should now fail. We will now configure and test a sign-in method. In the Firestore Console, in 'Develop - Authentication', click on 'Set up sign-in method'. Enable Email/Password sign-up and save. In the CRUD App, navigate to the multi-purpose 'Auth' screen (/screen/auth/). Enter your email and a password and click the 'Sign Up' button. The new user should appear in the Firestore Authentication list of Users. Check your email and click on the link you received (The email can be customized on the Firestore Authentication Templates tab). Return to the Auth screen (/screen/auth/) and click the 'Sign In' button. If the login succeeded, 'Add data' on the 'Live CRUD' screen should now succeed, and you should see the added data in the Firestore database console. Summary: You learnt how to create your own Firestore database, insert data and add authentication to the app, along with using datatables. Firestore replaces MongoDB, but also ORM, REST, DevOps, Security, Failover, etc. Instead of learning all of these, now you only need to learn how to use Firestore. That should create a huge savings in your development and operations budget. NEXT STEPS: You can try out more Template projects (type $ mbake ). You can also setup a META build server. META has a watcher that triggers 'mbake' when you save a file to a mapped drive. You can become 10X more productive by adopting the Metabase approach. Definitely look at: Awesome list of MetaBake resources https://git.mBake.org . In the next tutorial , we cover a view-model pattern . NEXT: Go to Simple CRUD example app and ViewModel+Bind .","title":"Steps"},{"location":"design/","text":"Design Design of UI is very important because it is the first thing that customer see on project (before the functionallity and code), so UI should be nice, at least neat, match colors, fonts, and shape of main controls and blocks on site. We use Spectre scss framework as default design UI, so you need to know Spectre well, which blocks and visual functionallity is has, to look when you'll get a task to do some block on real project. Also the UI should be responsive, Spectre has a section in the docs dedicated to the responsive layout. For more information on Spectre SCSS framework see Spectre docs In the next tutorial , we cover a blog website . NEXT: Go to Blog .","title":"Design"},{"location":"design/#design","text":"Design of UI is very important because it is the first thing that customer see on project (before the functionallity and code), so UI should be nice, at least neat, match colors, fonts, and shape of main controls and blocks on site. We use Spectre scss framework as default design UI, so you need to know Spectre well, which blocks and visual functionallity is has, to look when you'll get a task to do some block on real project. Also the UI should be responsive, Spectre has a section in the docs dedicated to the responsive layout. For more information on Spectre SCSS framework see Spectre docs In the next tutorial , we cover a blog website . NEXT: Go to Blog .","title":"Design"},{"location":"dynamic_data_binding/","text":"Learn serverless websites with dynamic databinding. A webapp is just a dynamic website. This tutorial helps you understand an example of a serverless website. Whether you plan to build a webapp or not, this tutorial is a good foundation. In this tutorial we cover these key concepts: appshell, includes, routes, custom tags, link lists, content lists, dependency management and serverless email. This includes dynamic databinding, where the browser ('client') uses data from a JSON response to dynamically render content client-side . We assume that you have already installed the example website project as described here ; generated with $ mbake -s and running on S3. Steps The example website uses an appshell for the parts of a website that are common to all pages. To understand how this works using Pug, inspect /zabout/about/index.pug and /get-started/index.pug . These Pug files show how the parts of the HTML they have in common are pulled from central places. Both pages use or 'extend' the template /layout/layout.pug . Open this template file, and see that it has 'blocks' named 'head2' , and 'main' . The Pug pages that extend this template define how to replace (or 'fill') these blocks. Each page defines that the 'main' block consists of a page-specific content. The website also makes use of Pug include . Looking at /zabout/contact/index.pug you see that the 'main' block includes fragment email.pug for the email form. We also can re-use email.pug anywhere else on page or in other pages. Now inspect /zabout/about/index.html . This is the complete HTML which mbake has collated together from template, fragments and dat.yaml. Since S3 returns the 'default' page index.html when the browser requests /zabout/about/ , this is what the end user sees. Application routes are defined with a href tags. Inspect /layout/navJBar.pug for examples. When a user clicks on a link, the URL in the browser changes and the respective content, such as /landing/why/index.html is returned. Users can bookmark individual URLs. The browser maintains a navigation history so that using its 'Back' button yields the expected result. We use Riot.js for custom tags. We use it when we need a new tag or want to hide functions and vars. To learn how Riot tags are written and used in Pug, inspect /riotFirst/tags/first-tag.pug . It looks something like this: first-tag p Dynamic Data: p { num } script. doSomething(arg) { console.info('arg: ', arg) this.update({num: arg}) } When 'doSomething()' gets called, it updates the {num} . You would run '$ mbake -t .' to generate a first-tag.js file to include in your page. mbake looks for files that end in '-tag.pug' . /riotFirst/index.pug uses this tag and looks like this: head title #{title} body //- include Riot script(src='//cdn.jsdelivr.net/npm/riot@3.11.2/riot.min.js') //- include the tag script script(src='tags/first-tag.min.js') p div //- use the tag first-tag script. var firstTag = riot.mount('first-tag')[0] // get the tag firstTag.doSomething(42) // call the logic You can see it working by going to /riotFirst/ in the browser. We can render a list of links from a list.json . Navigate to the 'News' menu item. Inspect /news/index.pug . We use Axios to load the JSON and our custom riot tag table-tag to dynamically render the list of links in the browser. Note that we begin loading the JSON as early as possible, in parallel with the UI, so users have to wait less. Now inspect /news/tag/table-tag.pug and note the use of Pug each={items} with JavaScript to iterate through the items in list.json . You use '$ mbake -t .' to generate table-tag.js . It is incorporated in /news/index.pug . There's no need to write JSON by hand, as you can process a list.csv to list.json with '$ mbakeW -j .' . This is a great way to build lists that change over time. Inspect /assets/js/loader.js . We use a tiny dependency manager (862 bytes) to facilitate the loading of required libraries in parallel with the UI. Take another look at /zabout/contect/email.pug and the use of depp.require(['css'], setupEmail) . We use it to signal when an inline dependency has been met (a process is 'done' and code is 'ready' for execution). Finally, we use EmailJS to send email from the /zabout/contact page without any server code. Another feature of mbake allows you to generate an AMP version of a website that has no custom JavaScript. More about this in another upcoming tutorial. Summary : in this tutorial, you've learned about appshell, includes, routes, custom tags, link lists, content lists and serverless email, along with dynamic data binding. In the next tutorial , we cover a serverless CRUD webapp . NEXT: Go to Generate a serverless CRUD webapp .","title":"dynamic databinding"},{"location":"dynamic_data_binding/#learn-serverless-websites-with-dynamic-databinding","text":"A webapp is just a dynamic website. This tutorial helps you understand an example of a serverless website. Whether you plan to build a webapp or not, this tutorial is a good foundation. In this tutorial we cover these key concepts: appshell, includes, routes, custom tags, link lists, content lists, dependency management and serverless email. This includes dynamic databinding, where the browser ('client') uses data from a JSON response to dynamically render content client-side . We assume that you have already installed the example website project as described here ; generated with $ mbake -s and running on S3.","title":"Learn serverless websites with dynamic databinding."},{"location":"dynamic_data_binding/#steps","text":"The example website uses an appshell for the parts of a website that are common to all pages. To understand how this works using Pug, inspect /zabout/about/index.pug and /get-started/index.pug . These Pug files show how the parts of the HTML they have in common are pulled from central places. Both pages use or 'extend' the template /layout/layout.pug . Open this template file, and see that it has 'blocks' named 'head2' , and 'main' . The Pug pages that extend this template define how to replace (or 'fill') these blocks. Each page defines that the 'main' block consists of a page-specific content. The website also makes use of Pug include . Looking at /zabout/contact/index.pug you see that the 'main' block includes fragment email.pug for the email form. We also can re-use email.pug anywhere else on page or in other pages. Now inspect /zabout/about/index.html . This is the complete HTML which mbake has collated together from template, fragments and dat.yaml. Since S3 returns the 'default' page index.html when the browser requests /zabout/about/ , this is what the end user sees. Application routes are defined with a href tags. Inspect /layout/navJBar.pug for examples. When a user clicks on a link, the URL in the browser changes and the respective content, such as /landing/why/index.html is returned. Users can bookmark individual URLs. The browser maintains a navigation history so that using its 'Back' button yields the expected result. We use Riot.js for custom tags. We use it when we need a new tag or want to hide functions and vars. To learn how Riot tags are written and used in Pug, inspect /riotFirst/tags/first-tag.pug . It looks something like this: first-tag p Dynamic Data: p { num } script. doSomething(arg) { console.info('arg: ', arg) this.update({num: arg}) } When 'doSomething()' gets called, it updates the {num} . You would run '$ mbake -t .' to generate a first-tag.js file to include in your page. mbake looks for files that end in '-tag.pug' . /riotFirst/index.pug uses this tag and looks like this: head title #{title} body //- include Riot script(src='//cdn.jsdelivr.net/npm/riot@3.11.2/riot.min.js') //- include the tag script script(src='tags/first-tag.min.js') p div //- use the tag first-tag script. var firstTag = riot.mount('first-tag')[0] // get the tag firstTag.doSomething(42) // call the logic You can see it working by going to /riotFirst/ in the browser. We can render a list of links from a list.json . Navigate to the 'News' menu item. Inspect /news/index.pug . We use Axios to load the JSON and our custom riot tag table-tag to dynamically render the list of links in the browser. Note that we begin loading the JSON as early as possible, in parallel with the UI, so users have to wait less. Now inspect /news/tag/table-tag.pug and note the use of Pug each={items} with JavaScript to iterate through the items in list.json . You use '$ mbake -t .' to generate table-tag.js . It is incorporated in /news/index.pug . There's no need to write JSON by hand, as you can process a list.csv to list.json with '$ mbakeW -j .' . This is a great way to build lists that change over time. Inspect /assets/js/loader.js . We use a tiny dependency manager (862 bytes) to facilitate the loading of required libraries in parallel with the UI. Take another look at /zabout/contect/email.pug and the use of depp.require(['css'], setupEmail) . We use it to signal when an inline dependency has been met (a process is 'done' and code is 'ready' for execution). Finally, we use EmailJS to send email from the /zabout/contact page without any server code. Another feature of mbake allows you to generate an AMP version of a website that has no custom JavaScript. More about this in another upcoming tutorial. Summary : in this tutorial, you've learned about appshell, includes, routes, custom tags, link lists, content lists and serverless email, along with dynamic data binding. In the next tutorial , we cover a serverless CRUD webapp . NEXT: Go to Generate a serverless CRUD webapp .","title":"Steps"},{"location":"model/","text":"Simple CRUD example app and ViewModel+Bind ViewModel A ViewModel maps to a page/screen. A ViewModel should be named after a page and each page should have a ViewModel. (Rarely a page has 2 ViewModels, for example if there is a Tag/Component that is on more than one page/screen that has it's own ViewModel) So if there is a table in the screen/page, the ViewModel would have a public property of an array or such. If there is a form, the ViewModel would have a public property of an object that has the fields_names that map form_input_names. And if there are 2 tables and two form, then the ViewModel has 2 public arrays and 2 public objects. So binding is easy. And each ViewModel should be discreet. The CRUD and Fetch() that ViewModel is just plumbing. 98% of VideModel is mapping it to a view(pug) page|screen. CRUD stands for create-read-update-delete. These are the basic operations that a simple web app would be designed to achieve. After you will create simple CRUD app you will create your own Firestore database, insert data and add authentication to the app. Firestore is Firebase\u2019s new database. It\u2019s designed to store and sync app data at global scale easily. It\u2019s a managed NoSQL document-oriented database for mobile and web development. Firestore includes pure client-side user authentication and can be used from the browser via JavaScript. No custom serverside code is needed. This is key to be able to develop faster. You will need to learn about http://tabulator.info/ which allows you to create interactive tables in seconds from any HTML Table, JavaScript Array, AJAX data source or JSON formatted data. Steps for creating simple CRUD app For an example dynamic web app CRUD in console type: $ mbake -c This command will extract the CRUD sample project to your computer. If you are using S3 buckets you can copy the project files (inside of /crud) into the project root, so in a browser you should see the CRUD App served by S3 with your endpoint URL Navigate to the 'Tabu' menu item and inspect the fragment /tabu/list.pug. Note the #example-table tag and the new Tabulator() function that converts the table into a datatable with headers and data. Now, navigate to the 'ViewModel CRUD' and 'ViewModel CRUD 2' menu items. First inspect the fragment models/OneModel.ts, and its methods (read, add, update, delete and valid), and after that inspect the fragments viewmodel/TableBind.js and view-model-2/bind.js. To learn Firebase, you will now remap the Firestore connection to your own Firestore. Create a Google account if you don't already have one. Log into https://console.firebase.google.com. Create a project named test-crud. Under the left menu 'Develop - Database', create a Firestore app in test mode. On the Project Overview, click the button near 'Add an app to get started' to open a popup. In your mapped project /assets/tags/preRW-tag.pug, overwrite the values for apiKey, authDomain and projectId with the values shown in the Firestore popup and save. From the tags folder run: $ mbake -t . /layout/layout.pug will use the updated script(src='/assets/tags/preRW-tag.min.js'). In a browser, refresh the Live CRUD page. Inspect /viewmodel/form/FormBind.js and /viewmodel/form/index.pug. Back in the browser enter some data in the form fields and click 'Save data'. Back in the Firestore Console, in 'Develop - Database', you should see the inserted data as first item in 'table_one'. Repeat to insert a second item. You will now secure the database. In the Firestore Console, on the Rules tab in 'Develop - Database', replace allow: read, write; with allow read, write: if request.auth.token.email_verified == true; Publish the change. Only logged in users who have been verified by email can now read from or write to the database. Since you are currently not logged in, 'Add data' on the 'CRUD' screen should now fail. You will now configure and test a sign-in method. In the Firestore Console, in 'Develop - Authentication', click on 'Set up sign-in method'. Enable Email/Password sign-up and save. In the CRUD App, navigate to the multi-purpose 'Auth' screen (/screen/auth/). Enter your email and a password and click the 'Sign Up' button. The new user should appear in the Firestore Authentication list of Users. Check your email and click on the link you received (The email can be customized on the Firestore Authentication Templates tab). Return to the Auth screen (/screen/auth/) and click the 'Sign In' button. If the login succeeded, 'Save data' on the 'ViewModel CRUD' screen should now succeed, and you should see the added data in the Firestore database console. ViewModel+Bind Separate the UI from data ViewModel is a great way of organizing your code, so each section of your code has a purpose, and those purposes are different. There is a 'models' folder inside assets, where we describe each class/model without UI, its typescript. The models do the heavy lifting, eg: call the service and prepare data in a way that is needed for the View and Pug. To compile the changes in the typescript file, do the command from the 'models' folder: $ tsc Each page will have its own binding class eg: TableBind where we do data binding there is no calls to Model classes from the pages. If you want to get any data, you need to create Binding class in the same folder, and from there make a call to the Model class. In the next tutorial , we cover 6 fundamental elements of design . NEXT: Go to 6 fundamental elements of design .","title":"Simple CRUD example app and ViewModel+Bind"},{"location":"model/#simple-crud-example-app-and-viewmodelbind","text":"","title":"Simple CRUD example app and ViewModel+Bind"},{"location":"model/#viewmodel","text":"A ViewModel maps to a page/screen. A ViewModel should be named after a page and each page should have a ViewModel. (Rarely a page has 2 ViewModels, for example if there is a Tag/Component that is on more than one page/screen that has it's own ViewModel) So if there is a table in the screen/page, the ViewModel would have a public property of an array or such. If there is a form, the ViewModel would have a public property of an object that has the fields_names that map form_input_names. And if there are 2 tables and two form, then the ViewModel has 2 public arrays and 2 public objects. So binding is easy. And each ViewModel should be discreet. The CRUD and Fetch() that ViewModel is just plumbing.","title":"ViewModel"},{"location":"model/#98-of-videmodel-is-mapping-it-to-a-viewpug-pagescreen","text":"CRUD stands for create-read-update-delete. These are the basic operations that a simple web app would be designed to achieve. After you will create simple CRUD app you will create your own Firestore database, insert data and add authentication to the app. Firestore is Firebase\u2019s new database. It\u2019s designed to store and sync app data at global scale easily. It\u2019s a managed NoSQL document-oriented database for mobile and web development. Firestore includes pure client-side user authentication and can be used from the browser via JavaScript. No custom serverside code is needed. This is key to be able to develop faster. You will need to learn about http://tabulator.info/ which allows you to create interactive tables in seconds from any HTML Table, JavaScript Array, AJAX data source or JSON formatted data.","title":"98% of VideModel is mapping it to a view(pug) page|screen."},{"location":"model/#steps-for-creating-simple-crud-app","text":"For an example dynamic web app CRUD in console type: $ mbake -c This command will extract the CRUD sample project to your computer. If you are using S3 buckets you can copy the project files (inside of /crud) into the project root, so in a browser you should see the CRUD App served by S3 with your endpoint URL Navigate to the 'Tabu' menu item and inspect the fragment /tabu/list.pug. Note the #example-table tag and the new Tabulator() function that converts the table into a datatable with headers and data. Now, navigate to the 'ViewModel CRUD' and 'ViewModel CRUD 2' menu items. First inspect the fragment models/OneModel.ts, and its methods (read, add, update, delete and valid), and after that inspect the fragments viewmodel/TableBind.js and view-model-2/bind.js. To learn Firebase, you will now remap the Firestore connection to your own Firestore. Create a Google account if you don't already have one. Log into https://console.firebase.google.com. Create a project named test-crud. Under the left menu 'Develop - Database', create a Firestore app in test mode. On the Project Overview, click the button near 'Add an app to get started' to open a popup. In your mapped project /assets/tags/preRW-tag.pug, overwrite the values for apiKey, authDomain and projectId with the values shown in the Firestore popup and save. From the tags folder run: $ mbake -t . /layout/layout.pug will use the updated script(src='/assets/tags/preRW-tag.min.js'). In a browser, refresh the Live CRUD page. Inspect /viewmodel/form/FormBind.js and /viewmodel/form/index.pug. Back in the browser enter some data in the form fields and click 'Save data'. Back in the Firestore Console, in 'Develop - Database', you should see the inserted data as first item in 'table_one'. Repeat to insert a second item. You will now secure the database. In the Firestore Console, on the Rules tab in 'Develop - Database', replace allow: read, write; with allow read, write: if request.auth.token.email_verified == true; Publish the change. Only logged in users who have been verified by email can now read from or write to the database. Since you are currently not logged in, 'Add data' on the 'CRUD' screen should now fail. You will now configure and test a sign-in method. In the Firestore Console, in 'Develop - Authentication', click on 'Set up sign-in method'. Enable Email/Password sign-up and save. In the CRUD App, navigate to the multi-purpose 'Auth' screen (/screen/auth/). Enter your email and a password and click the 'Sign Up' button. The new user should appear in the Firestore Authentication list of Users. Check your email and click on the link you received (The email can be customized on the Firestore Authentication Templates tab). Return to the Auth screen (/screen/auth/) and click the 'Sign In' button. If the login succeeded, 'Save data' on the 'ViewModel CRUD' screen should now succeed, and you should see the added data in the Firestore database console.","title":"Steps for creating simple CRUD app"},{"location":"model/#viewmodelbind","text":"Separate the UI from data ViewModel is a great way of organizing your code, so each section of your code has a purpose, and those purposes are different. There is a 'models' folder inside assets, where we describe each class/model without UI, its typescript. The models do the heavy lifting, eg: call the service and prepare data in a way that is needed for the View and Pug. To compile the changes in the typescript file, do the command from the 'models' folder: $ tsc Each page will have its own binding class eg: TableBind where we do data binding there is no calls to Model classes from the pages. If you want to get any data, you need to create Binding class in the same folder, and from there make a call to the Model class. In the next tutorial , we cover 6 fundamental elements of design . NEXT: Go to 6 fundamental elements of design .","title":"ViewModel+Bind"},{"location":"npm/","text":"How to install mbake with NPM The simplest way to install mbake is using Yarn. But if you use some additional flags, you can use NPM instead. NPM needs the extra flags to be able to install Electron. Electron is used for the watcher (mbake -w). From a command line such as PowerShell, type: npm i -g mbake --unsafe-perm=true --allow-root That's it! If you don't have Node with NPM installed, first go here for Windows or here for MAC .","title":"Npm"},{"location":"npm/#how-to-install-mbake-with-npm","text":"The simplest way to install mbake is using Yarn. But if you use some additional flags, you can use NPM instead. NPM needs the extra flags to be able to install Electron. Electron is used for the watcher (mbake -w). From a command line such as PowerShell, type: npm i -g mbake --unsafe-perm=true --allow-root That's it! If you don't have Node with NPM installed, first go here for Windows or here for MAC .","title":"How to install mbake with NPM"},{"location":"pug_static_data/","text":"Learn Templating/Pug and static binding; view via S3 HTTP server. Simply said, Pug is HTML without closing tags. Pug is a templating language, more powerful than Markdown . If you know Node/Express, you know Pug already. If you know HTML, you also mostly know Pug: just don't close the tags. Pug also has variables (e.g. #{key1} ) and imports (e.g. include fragment.pug ). This Pug: header body p Hello #{key1} with key1:World (from dat.yaml in our case) becomes this HTML: <header></header> <body> <p> Hello World</p> </body> Pug is more concise, more powerful and easier to read and write than HTML. With Pug, you can also change the layout of your app; which is hard to do in Markdown. Because Markdown is useful for integrating larger bodies of text into HTML, mbake also supports include:metaMD mytext.md in Pug. We see Pug as a declarative 4th generation language (4GL). As we went from second generation assembly language (2GL) to higher level third generation (3GL, like C, C#, Java and JavaScript), our productivity jumped. Pug 4GL gets you to yet higher levels of productivity. Steps We assume that you have already installed mbake with $ yarn global add mbake as described here . Watch Do you even Jade bro as an intro about Pug (it used to be called Jade). Generate a sample website with $ mbake -s and copy the contents of the generated website folder to the bucket you mapped in Tutorial 1 , e.g. W:\\wgehner-website . Open this as a project in your favorite code editor (we like VS Code). In the Amazon S3 browser, go to the /assets/css folder, check all CSS files, select 'More - change metadata', and set 'Content-type' to text/css . View the app in a browser. Use the S3 URL from Tutorial 1 . For production, you can mask the URL with a proper domain with HTTPS by using a CDN. On the website, navigate to the /zabout/about/ page. In your code editor, go to the /zabout/about/ folder, edit dat.yaml and change 'About Us' to 'About Me' , save, then $ mbake . and refresh the browser. Of course you could also change something in index.pug . You can also use mbake live reload/watcher/compiler from the root folder of your project, this command will automatically compile .pug to .html and *-tag.pug to *-tag.js , and also scss/sass to css: $ mbakeW -w . About dat.yaml mbake looks for dat.yaml in each folder and uses it for static binding. If you have 'bla: Oh hi' in dat.yaml , you can use the value inside a .pug file at compile time via: #{bla} That will put 'Oh hi' , the value of bla at compile time, into the HTML. This is especially useful for any SEO items that can be repetitive in the HTML source. Summary : In this tutorial, you learnt about Pug and static data binding. In the next tutorial , we cover spectre css framework and scss . NEXT: Go to Spectre SCSS Theme Framework and SCSS .","title":"Learn Templating/Pug"},{"location":"pug_static_data/#learn-templatingpug-and-static-binding-view-via-s3-http-server","text":"Simply said, Pug is HTML without closing tags. Pug is a templating language, more powerful than Markdown . If you know Node/Express, you know Pug already. If you know HTML, you also mostly know Pug: just don't close the tags. Pug also has variables (e.g. #{key1} ) and imports (e.g. include fragment.pug ). This Pug: header body p Hello #{key1} with key1:World (from dat.yaml in our case) becomes this HTML: <header></header> <body> <p> Hello World</p> </body> Pug is more concise, more powerful and easier to read and write than HTML. With Pug, you can also change the layout of your app; which is hard to do in Markdown. Because Markdown is useful for integrating larger bodies of text into HTML, mbake also supports include:metaMD mytext.md in Pug. We see Pug as a declarative 4th generation language (4GL). As we went from second generation assembly language (2GL) to higher level third generation (3GL, like C, C#, Java and JavaScript), our productivity jumped. Pug 4GL gets you to yet higher levels of productivity.","title":"Learn Templating/Pug and static binding; view via S3 HTTP server."},{"location":"pug_static_data/#steps","text":"We assume that you have already installed mbake with $ yarn global add mbake as described here . Watch Do you even Jade bro as an intro about Pug (it used to be called Jade). Generate a sample website with $ mbake -s and copy the contents of the generated website folder to the bucket you mapped in Tutorial 1 , e.g. W:\\wgehner-website . Open this as a project in your favorite code editor (we like VS Code). In the Amazon S3 browser, go to the /assets/css folder, check all CSS files, select 'More - change metadata', and set 'Content-type' to text/css . View the app in a browser. Use the S3 URL from Tutorial 1 . For production, you can mask the URL with a proper domain with HTTPS by using a CDN. On the website, navigate to the /zabout/about/ page. In your code editor, go to the /zabout/about/ folder, edit dat.yaml and change 'About Us' to 'About Me' , save, then $ mbake . and refresh the browser. Of course you could also change something in index.pug . You can also use mbake live reload/watcher/compiler from the root folder of your project, this command will automatically compile .pug to .html and *-tag.pug to *-tag.js , and also scss/sass to css: $ mbakeW -w .","title":"Steps"},{"location":"pug_static_data/#about-datyaml","text":"mbake looks for dat.yaml in each folder and uses it for static binding. If you have 'bla: Oh hi' in dat.yaml , you can use the value inside a .pug file at compile time via: #{bla} That will put 'Oh hi' , the value of bla at compile time, into the HTML. This is especially useful for any SEO items that can be repetitive in the HTML source. Summary : In this tutorial, you learnt about Pug and static data binding. In the next tutorial , we cover spectre css framework and scss . NEXT: Go to Spectre SCSS Theme Framework and SCSS .","title":"About dat.yaml"},{"location":"res/","text":"Awesome Low-code list of MetaBake resources https://github.com/metabake/MetaBake-Docs/tree/master/awesomeReference","title":"Resources"},{"location":"res/#awesome-low-code-list-of-metabake-resources","text":"https://github.com/metabake/MetaBake-Docs/tree/master/awesomeReference","title":"Awesome Low-code list of MetaBake resources"},{"location":"s3_n_webdrive_mount/","text":"Setup S3 as your HTTP server and mount it mbake is Cloud v2.0. You do not need to install or maintain any HTTP, DB or any other server. Steps Create an AWS account if you don't already have one. In AWS Menu 'Account - My Security Credentials', create a new Access Key , click 'Show Access Key', and copy it (to a file) for use below. (Advanced users can later use IAM instead.) Create an AWS S3 'bucket' in the \"US East (N Virginia)\" region. (Advanced users can select any region). Name the bucket 'wgehner-website' (replace wgehner with your name or something else unique). On the bucket 'Properties' tab, select 'Static website hosting' and 'Use this bucket to host a website'. Copy the 'Endpoint URL' for use below. Once created, on the Detail Permissions tab, configure the access policy so that the bucket can be accessed via HTTP. Replace 'wgehner-website' with your bucket name. { \"Version\":\"2012-10-17\", \"Statement\": [{ \"Sid\":\"PublicReadGetObject\", \"Effect\":\"Allow\", \"Principal\": \"*\", \"Action\":[\"s3:GetObject\"], \"Resource\":[\"arn:aws:s3:::wgehner-website/*\" ] }] } Under 'Permissions' tab in 'Public access settings' subtab make sure that all blocking public access checkboxes are set to false , unchecked (if no, the bucket url can not be accessed) Install Web Drive for Windows or on Mac Mountain Duck users may choose a different mount software. There are more than a dozen other choices ). Mount replaces FTP. In WebDrive, create a new Amazon S3 connection. Choose a drive letter (e.g. W:\\ ). Paste Access Key ID and Secret Access Key created in Step 1 above. If your bucket region is not \"US East (N Virginia)\", edit the S3 Account URL/Address to match the \"Endpoint URL' in this list . Example: change https://s3.amazonaws.com to https://s3.us-west-1.amazonaws.com if your region is US West (N. California). Do not select a specific bucket. This way all buckets for the region will show up as top level folders in the mounted drive, and your mounted drive letter effectively represents an S3 region in your AWS account. To verify that the mount is working, you can put an index.html into the mounted bucket project root (e.g. W:\\wgehner-website ) on your file system. You might just copy-paste the index.html you generated here . Then view it in the browser via the Endpoint URL copied in Step 3 above. Summary : With Cloud hosting and mount, you can edit apps from your filesystem and see the edits reflected on the web without extra deployment work. In the next tutorial you will learn how to mount s3 bucket to Linux box on CodeAnywhere. NEXT: Go to Mount S3 to linux box via goofys using CodeAnywhere editor .","title":"Setup S3 and webdrive mount"},{"location":"s3_n_webdrive_mount/#setup-s3-as-your-http-server-and-mount-it","text":"mbake is Cloud v2.0. You do not need to install or maintain any HTTP, DB or any other server.","title":"Setup S3 as your HTTP server and mount it"},{"location":"s3_n_webdrive_mount/#steps","text":"Create an AWS account if you don't already have one. In AWS Menu 'Account - My Security Credentials', create a new Access Key , click 'Show Access Key', and copy it (to a file) for use below. (Advanced users can later use IAM instead.) Create an AWS S3 'bucket' in the \"US East (N Virginia)\" region. (Advanced users can select any region). Name the bucket 'wgehner-website' (replace wgehner with your name or something else unique). On the bucket 'Properties' tab, select 'Static website hosting' and 'Use this bucket to host a website'. Copy the 'Endpoint URL' for use below. Once created, on the Detail Permissions tab, configure the access policy so that the bucket can be accessed via HTTP. Replace 'wgehner-website' with your bucket name. { \"Version\":\"2012-10-17\", \"Statement\": [{ \"Sid\":\"PublicReadGetObject\", \"Effect\":\"Allow\", \"Principal\": \"*\", \"Action\":[\"s3:GetObject\"], \"Resource\":[\"arn:aws:s3:::wgehner-website/*\" ] }] } Under 'Permissions' tab in 'Public access settings' subtab make sure that all blocking public access checkboxes are set to false , unchecked (if no, the bucket url can not be accessed) Install Web Drive for Windows or on Mac Mountain Duck users may choose a different mount software. There are more than a dozen other choices ). Mount replaces FTP. In WebDrive, create a new Amazon S3 connection. Choose a drive letter (e.g. W:\\ ). Paste Access Key ID and Secret Access Key created in Step 1 above. If your bucket region is not \"US East (N Virginia)\", edit the S3 Account URL/Address to match the \"Endpoint URL' in this list . Example: change https://s3.amazonaws.com to https://s3.us-west-1.amazonaws.com if your region is US West (N. California). Do not select a specific bucket. This way all buckets for the region will show up as top level folders in the mounted drive, and your mounted drive letter effectively represents an S3 region in your AWS account. To verify that the mount is working, you can put an index.html into the mounted bucket project root (e.g. W:\\wgehner-website ) on your file system. You might just copy-paste the index.html you generated here . Then view it in the browser via the Endpoint URL copied in Step 3 above. Summary : With Cloud hosting and mount, you can edit apps from your filesystem and see the edits reflected on the web without extra deployment work. In the next tutorial you will learn how to mount s3 bucket to Linux box on CodeAnywhere. NEXT: Go to Mount S3 to linux box via goofys using CodeAnywhere editor .","title":"Steps"},{"location":"spectre_n_scss/","text":"Spectre SCSS Theme Framework and SCSS Spectre The default SCSS theme framework used in most examples is Spectre CSS . Spectre is small (~10KB) but fully featured and easy to use. Spectre does not use JavaScript, which makes it AMP-compatible - a big plus for content-driven sites and apps. SCSS SCSS is the same as css, but what's more is that in scss there are supports nested elements, eg(from spectre _accordions.scss): .accordion-header { display: block; padding: $unit-1 $unit-2; .icon { transition: transform .25s; } } Also in scss there are available variables, as you can see from the previous example $unit-1 $unit-2 , and mixins \u2014 the parts of scss code that can be reused in other scss files or properties. The main scss differences from usual css are: nested elements variables mixins assets.yaml In our project we use mbake scss compiler, it works through assets.yaml eg: - https://github.com/metabake/MetaBake-Docs/tree/master/meta-website/assets There is list of sass files in assets.yaml and it will compile to /assets/css folder. So you can just run the command from the 'assets' folder to compile scss/sass to css: $ mbakeW -s . or any path in assets or any sub folder under assets and it will compile scss/sass to css. It won't work for folders other than /assets, or if there is no assets.yaml properly configured in assets. You can also use mbake live reload/watcher/compiler from the root folder of your project, this command will automatically compile scss/sass to css as well as .pug to .html , and *-tag.pug to *-tag.js . The command is: $ mbakeW -w . In the next tutorial , we cover dynamic databinding . Learn more about SCSS ans SASS here NEXT: Go to dynamic databinding .","title":"Spectre SCSS Theme Framework and SCSS"},{"location":"spectre_n_scss/#spectre-scss-theme-framework-and-scss","text":"","title":"Spectre SCSS Theme Framework and SCSS"},{"location":"spectre_n_scss/#spectre","text":"The default SCSS theme framework used in most examples is Spectre CSS . Spectre is small (~10KB) but fully featured and easy to use. Spectre does not use JavaScript, which makes it AMP-compatible - a big plus for content-driven sites and apps.","title":"Spectre"},{"location":"spectre_n_scss/#scss","text":"SCSS is the same as css, but what's more is that in scss there are supports nested elements, eg(from spectre _accordions.scss): .accordion-header { display: block; padding: $unit-1 $unit-2; .icon { transition: transform .25s; } } Also in scss there are available variables, as you can see from the previous example $unit-1 $unit-2 , and mixins \u2014 the parts of scss code that can be reused in other scss files or properties. The main scss differences from usual css are: nested elements variables mixins","title":"SCSS"},{"location":"spectre_n_scss/#assetsyaml","text":"In our project we use mbake scss compiler, it works through assets.yaml eg: - https://github.com/metabake/MetaBake-Docs/tree/master/meta-website/assets There is list of sass files in assets.yaml and it will compile to /assets/css folder. So you can just run the command from the 'assets' folder to compile scss/sass to css: $ mbakeW -s . or any path in assets or any sub folder under assets and it will compile scss/sass to css. It won't work for folders other than /assets, or if there is no assets.yaml properly configured in assets. You can also use mbake live reload/watcher/compiler from the root folder of your project, this command will automatically compile scss/sass to css as well as .pug to .html , and *-tag.pug to *-tag.js . The command is: $ mbakeW -w . In the next tutorial , we cover dynamic databinding . Learn more about SCSS ans SASS here NEXT: Go to dynamic databinding .","title":"assets.yaml"}]}